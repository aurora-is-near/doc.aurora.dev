"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[4413],{4463:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=a(3274),n=a(7507);const r={title:"EVM gas vs. Near gas on Aurora",description:"How the Aurora's EVM gas and Near gas are related? What gas limits do we have, and how Engine optimizations are saving your costs?",date:"2023-07-07",authors:["michael"],tags:["core_tech"],image:"https://www.datocms-assets.com/95026/1688080861-gas.png"},o=void 0,i={permalink:"/blog/evm-gas-near-gas-on-aurora",editUrl:"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/blog/evm-gas-near-gas-on-aurora.md",source:"@site/blog/evm-gas-near-gas-on-aurora.md",title:"EVM gas vs. Near gas on Aurora",description:"How the Aurora's EVM gas and Near gas are related? What gas limits do we have, and how Engine optimizations are saving your costs?",date:"2023-07-07T00:00:00.000Z",tags:[{inline:!1,label:"Core Tech",permalink:"/blog/tags/core_tech",description:"Posts about core technologies on Aurora"}],readingTime:5.733333333333333,hasTruncateMarker:!0,authors:[{name:"Michael Birch",title:"Senior Research Engineer",imageURL:"https://www.datocms-assets.com/95026/1683043123-t025c6kc9px-u025f7t5npl-c56792be0091-512.jpeg",key:"michael",page:null}],frontMatter:{title:"EVM gas vs. Near gas on Aurora",description:"How the Aurora's EVM gas and Near gas are related? What gas limits do we have, and how Engine optimizations are saving your costs?",date:"2023-07-07",authors:["michael"],tags:["core_tech"],image:"https://www.datocms-assets.com/95026/1688080861-gas.png"},unlisted:!1,prevItem:{title:"How to get USDC tokens on Aurora testnet",permalink:"/blog/how-to-get-usdc-tokens-on-aurora-testnet"},nextItem:{title:"Aurora Cloud: Borealis Business",permalink:"/blog/aurora-cloud-borealis-business"}},h={authorsImageUrls:[void 0]},c=[{value:"The theoretical relation",id:"the-theoretical-relation",level:2},{value:"Gathering data",id:"gathering-data",level:2},{value:"Empirical results",id:"empirical-results",level:2},{value:"Future directions",id:"future-directions",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["A core piece of Aurora\u2019s technology is the ",(0,s.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine",children:(0,s.jsx)(t.em,{children:"Aurora Engine smart contract"})}),", which is an Ethereum Virtual Machine (EVM) implementation deployed as a smart contract on Near. Therefore, Aurora sits at the intersection of both EVM and Near runtimes. It naturally draws us to think about comparisons between EVM and Near."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, the concept of \u201cgas\u201d exists in both the EVM and Near\u2019s runtime. The reason is because of the famous ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Halting_problem",children:(0,s.jsx)(t.em,{children:"halting problem"})}),", which says we cannot know in advance if an arbitrary computer program will finish in a finite time. In the context of a smart contract platform, this means we must measure (and limit) the computation the contract does at runtime. In both the EVM and Near, \u201cgas\u201d is the unit that is used to measure the computational work done by a smart contract."]}),"\n",(0,s.jsx)(t.p,{children:"Even though EVM gas and Near gas both measure the same thing, they are not identical. One analogy is miles and kilometers; both measure distance, but the numerical value of the same physical distance will be different depending on which unit is used. Computation is a more abstract concept than distance, but this analogy leads us to expect some kind of approximately linear relationship between EVM gas and Near gas, similar to how 1 mile equals 1.61 kilometers."}),"\n",(0,s.jsx)(t.p,{children:"In this blog post, we explore this question and discuss the implications for developers building on Aurora."}),"\n",(0,s.jsx)(t.h2,{id:"the-theoretical-relation",children:"The theoretical relation"}),"\n",(0,s.jsx)(t.p,{children:"In theory, we should be able to derive the relationship between EVM gas and Near gas by considering the EVM gas cost of each operation in the EVM and calculating how much Near gas this same operation costs based on its implementation in Aurora. Unfortunately, this is much more difficult in practice than it sounds. The Aurora Engine is written in Rust and compiled to Web Assembly (Wasm)."}),"\n",(0,s.jsx)(t.p,{children:"This compilation process convolutes the conceptual mapping between EVM opcodes and operations in the Near runtime. There are additional complexities in trying to do this calculation in that Aurora virtualizes the whole EVM inside Wasm, and hence how much Near gas an opcode takes may depend on the overall VM state (e.g., because more Wasm memory needs to be allocated)."}),"\n",(0,s.jsx)(t.p,{children:"While it is good to have this idea of being able to calculate the relationship from first principles (and we will revisit it later in this post), it is not a practical way to answer our question. For that, we will use empirical data instead."}),"\n",(0,s.jsx)(t.h2,{id:"gathering-data",children:"Gathering data"}),"\n",(0,s.jsxs)(t.p,{children:["Data for EVM and Near gas used for all transactions on Aurora is available via a combination of our RPC and Near\u2019s RPC. Consider the following call (done via the command line using the ",(0,s.jsx)(t.a,{href:"https://httpie.org",children:(0,s.jsx)(t.em,{children:"HTTPie"})})," tool):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"http post https://mainnet.aurora.dev/ jsonrpc=2.0 id=1 \\\n  method=eth_getTransactionReceipt \\\n  params:='[\"0x4c2b8b5d766fe0411d0003bf4c9d2becc9d6dd7120272cf9f1a6cac73e4c3543\"]'\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The parameter in this call can be any hash of a transaction on Aurora (the given one is only an example). Notice the ",(0,s.jsx)(t.code,{children:"gasUsed"})," field in the response, which gives the (hexadecimal encoded) amount of EVM gas used in the transaction (46,574 in this example)."]}),"\n",(0,s.jsxs)(t.p,{children:["In addition to the standard response fields defined by the ",(0,s.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt",children:(0,s.jsx)(t.em,{children:"Ethereum standard"})}),", the Aurora RPC returns two other fields: `nearReceiptHash` and `nearTransactionHash`. These give the receipt/transaction hashes corresponding to the underlying transaction that was executed on Near (by the Aurora Engine contract)."]}),"\n",(0,s.jsxs)(t.p,{children:["To use these extra fields, there is some additional work involved because Near hashes are always presented in ",(0,s.jsx)(t.a,{href:"https://digitalbazaar.github.io/base58-spec/",children:(0,s.jsx)(t.em,{children:"base58 encoding"})}),", whereas our RPC returns them in hexadecimal encoding (to be consistent with how Ethereum usually presents hashes)."]}),"\n",(0,s.jsxs)(t.p,{children:["You can read more about this in a ",(0,s.jsx)(t.a,{href:"/blog/convert-aurora-transaction-into-near-s-one",children:(0,s.jsx)(t.em,{children:"previous article"})}),". For our purposes here, it is easy enough to write a ",(0,s.jsx)(t.a,{href:"https://gist.github.com/birchmd/a336269596651992ed9b742c843b9b0f",children:(0,s.jsx)(t.em,{children:"Python script to do the conversion"})})," for us and chain this together with the ",(0,s.jsx)(t.a,{href:"https://jqlang.github.io/jq/",children:(0,s.jsx)(t.em,{children:"jq tool"})})," to get the Near transaction hash in one command:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"http post https://mainnet.aurora.dev/ jsonrpc=2.0 id=1 \\\n method=eth_getTransactionReceipt \\\n params:='[\"0x4c2b8b5d766fe0411d0003bf4c9d2becc9d6dd7120272cf9f1a6cac73e4c3543\"]' \\\n | jq .result.nearTransactionHash | hex2b58\n"})}),"\n",(0,s.jsx)(t.p,{children:"From the Near transaction hash, we can get the amount of Near gas used in the transaction from the Near RPC:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:'http post https://archival-rpc.mainnet.near.org jsonrpc=2.0 id=dontcare \\\n  method=tx \\\n  params:=\'[ "46ACGRcUQadezAWQuZ9WVopSAbeeWpJZ1H8hmVuWPhJu", "relay.aurora"]\'\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Where the first parameter is the Near transaction hash obtained from the Aurora RPC by the previous command. There is a lot of data returned from the response, but for our purposes, we only care about the gas used in the Aurora Engine execution. We can isolate just this part of the response using ",(0,s.jsx)(t.code,{children:"jq"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"http post https://archival-rpc.mainnet.near.org jsonrpc=2.0 id=dontcare \\\n  method=tx \\\n  params:='[ \"46ACGRcUQadezAWQuZ9WVopSAbeeWpJZ1H8hmVuWPhJu\", \"relay.aurora\"]' \\\n  | jq '.result.receipts_outcome[0].outcome.gas_burnt'\n"})}),"\n",(0,s.jsx)(t.p,{children:"Given this, it\u2019s pretty easy to automate obtaining the EVM and Near gas data from any Aurora transactions we want!"}),"\n",(0,s.jsx)(t.h2,{id:"empirical-results",children:"Empirical results"}),"\n",(0,s.jsx)(t.p,{children:"In what follows, we consider all the successful (i.e., ignoring obvious failures like incorrect nonce \u2013 these would be outliers in our data because they don\u2019t do any real EVM execution) Aurora transactions from June 4, 2023 (block height 93442283) to June 12, 2023 (block height 94047083). Below is a plot of EVM gas vs Near gas. The Near numbers have been scaled by 10^12 since Tgas is the common unit Near gas values are presented in, and the EVM numbers have been scaled by 10^3 since the smallest EVM gas possible is 2100."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1688079135-screenshot-2023-06-29-at-23-51-52.png",alt:""})}),"\n",(0,s.jsx)(t.p,{children:"As expected, there is a strong linear correlation between the values. Though interestingly, there are (at least) 3 distinct lines as opposed to just one."}),"\n",(0,s.jsx)(t.p,{children:"The line with the shallowest slope (orange line in the plot) corresponds to storage-heavy transactions (e.g., contract deployments). These transactions use a lot of EVM gas but not very much Near gas. The reason is because of the difference in how the EVM charges for storage and how Near charges for it. In the EVM, storage access is pretty expensive in terms of gas, but there is a gas refund when storage is released."}),"\n",(0,s.jsxs)(t.p,{children:["On the other hand, Near does not change much gas for storage access but does charge the account in the form of ",(0,s.jsx)(t.a,{href:"https://docs.near.org/concepts/storage/storage-staking",children:(0,s.jsx)(t.em,{children:"storage staking"})})," (the account must maintain a minimum Near balance to be allowed to have so much storage used). This difference in how storage is charged means disproportionately less Near gas is used for storage compared to other computational costs (e.g., CPU and memory access)."]}),"\n",(0,s.jsx)(t.p,{children:"The majority of points in the plot lie on the steepest line (green line in the plot), though there is a lot of variance around it. Taking a linear regression of this data, we determine the average slope is around 0.122. This provides us an empirical answer to our question of how EVM and Near gas are related on Near. Approximately 1.22 x10^8 Near gas is spent per EVM gas. In fact, this relation is what informs the fixed EVM gas price set by Aurora\u2019s relayers."}),"\n",(0,s.jsxs)(t.p,{children:["The relationship between EVM gas and Near gas allows us to convert Near\u2019s gas price into an EVM gas price to charge our users (of course, most users take advantage of the free transaction available from ",(0,s.jsx)(t.a,{href:"https://aurora.dev/blog/introducing-aurora-pass-your-gateway-to-the-decentralized-web",children:(0,s.jsx)(t.em,{children:"AuroraPass"})})," and don\u2019t worry about gas prices anyway)."]}),"\n",(0,s.jsx)(t.p,{children:"The red line in the plot follows a distinct collection of points between the \u201cstorage-heavy\u201d and \u201cmain\u201d lines. I do not know what is special about these transactions, which makes them use less Near gas than those on the main trendline. It is difficult to learn high-level information about transactions just from the set of addresses they call and the binary input they send."}),"\n",(0,s.jsx)(t.p,{children:"One hypothesis could be that these transactions are literally a middle-ground between the two extremes of the gas, primarily coming from CPU costs and primarily coming from storage costs. There could be something about the algorithm the smart contracts implement such that the amount of storage access they need is proportional to the amount of CPU-bound computation they perform. Regardless of the reason, this may be useful information for the developers of those contracts to know since they are able to complete transactions with higher EVM gas values than transactions on the main line."}),"\n",(0,s.jsxs)(t.p,{children:["This data has additional consequences for developers on Aurora. For example, ",(0,s.jsx)(t.a,{href:"https://doc.aurora.dev/evm/evm-overview",children:(0,s.jsx)(t.em,{children:"our documentation"})})," mentions an edge case incompatibility between Aurora and Ethereum mainnet where a transaction may run out of Near gas before it runs out of EVM gas."]}),"\n",(0,s.jsx)(t.p,{children:"This causes the transaction to fail on Aurora when it would pass on Ethereum. The transaction gas limit on Near (no such concept exists on Ethereum, there is only the block gas limit) is 300 Tgas, which implies that this edge case described in the documentation arises for EVM transactions exceeding approximately 2.5 x 10^6 EVM gas. This assumes the transaction lies on the main trendline, though, as we discussed, there are other kinds of transactions with different Near/EVM gas conversion ratios that can achieve higher EVM gas values."}),"\n",(0,s.jsx)(t.h2,{id:"future-directions",children:"Future directions"}),"\n",(0,s.jsx)(t.p,{children:"For us internally at Aurora, this plot also gives us a clear metric for our Engine\u2019s performance. Our goal is to process EVM transactions as efficiently as possible (i.e., use as little Near gas as possible per EVM gas), which corresponds to lowering the slope of the main trendline in the EVM gas vs. Near gas plot."}),"\n",(0,s.jsx)(t.p,{children:"Since Aurora launched, we have made a lot of progress in this respect: more than a factor of 2 improvement since February 2022 (Engine v2.4.0 vs. v2.9.0).  But we still have more work to do. We would like to make the amount of EVM gas that fits into 300 Near Tgas equal to the Ethereum block gas limit (30 x 10^6 EVM gas) so that our developers no longer need to worry about the edge case discussed above."}),"\n",(0,s.jsx)(t.p,{children:"Because, in this case, we will be sure that no EVM transaction which succeeds on the Ethereum mainnet can exceed 300TGas on Near. Going back to the theoretical argument from earlier in the article, we know that we should be able to improve the Engine\u2019s efficiency by changing the implementation details. In particular, the overhead of running an EVM interpreter must contribute to the Near gas cost significantly."}),"\n",(0,s.jsxs)(t.p,{children:["Our next innovation towards this goal is to develop an ",(0,s.jsx)(t.a,{href:"https://github.com/aurora-is-near/evm2near",children:(0,s.jsx)(t.em,{children:"EVM to Wasm compiler"})}),". Such a compiler will allow directly executing EVM contracts in the Near runtime instead of needing to interpret them within a virtualized EVM. Some ",(0,s.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/pull/463",children:(0,s.jsx)(t.em,{children:"simple benchmarking data"})})," suggests that we should be able to get orders of magnitude performance improvements using this kind of approach."]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},7507:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>i});var s=a(9474);const n={},r=s.createContext(n);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);