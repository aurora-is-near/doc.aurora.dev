"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[5373],{4950:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var a=n(3274),o=n(7507);const i={title:"Turning Smart Contracts into Indexers",description:"Learn how you can use functional programming patterns in Rust to share a codebase between both a smart contract and an indexer, and how cross-compilation can benefit your project",date:"2023-08-25",authors:["michael"],tags:["tutorials"],image:"https://www.datocms-assets.com/95026/1692963087-tsci.png"},s=void 0,r={permalink:"/blog/turning-smart-contracts-into-indexers",editUrl:"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/blog/turning-smart-contracts-into-indexers.md",source:"@site/blog/turning-smart-contracts-into-indexers.md",title:"Turning Smart Contracts into Indexers",description:"Learn how you can use functional programming patterns in Rust to share a codebase between both a smart contract and an indexer, and how cross-compilation can benefit your project",date:"2023-08-25T00:00:00.000Z",tags:[{inline:!1,label:"Tutorials",permalink:"/blog/tags/tutorials",description:"Longer posts talking about the subject in detail"}],readingTime:4.98,hasTruncateMarker:!0,authors:[{name:"Michael Birch",title:"Senior Research Engineer",imageURL:"https://www.datocms-assets.com/95026/1683043123-t025c6kc9px-u025f7t5npl-c56792be0091-512.jpeg",key:"michael",page:null}],frontMatter:{title:"Turning Smart Contracts into Indexers",description:"Learn how you can use functional programming patterns in Rust to share a codebase between both a smart contract and an indexer, and how cross-compilation can benefit your project",date:"2023-08-25",authors:["michael"],tags:["tutorials"],image:"https://www.datocms-assets.com/95026/1692963087-tsci.png"},unlisted:!1,prevItem:{title:"Integration tests for XCC communication",permalink:"/blog/communication-from-aurora-to-near-local-testing"},nextItem:{title:"How to get USDC tokens on Aurora testnet",permalink:"/blog/how-to-get-usdc-tokens-on-aurora-testnet"}},c={authorsImageUrls:[void 0]},l=[{value:"Motivation",id:"motivation",level:2},{value:"Rust Features",id:"rust-features",level:2},{value:"Cross-Compilation",id:"cross-compilation",level:3},{value:"Conditional Compilation",id:"conditional-compilation",level:3},{value:"Traits and Type Generics",id:"traits-and-type-generics",level:3},{value:"Application: Aurora Engine",id:"application-aurora-engine",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["Recently, Michael Birch gave a ",(0,a.jsx)(t.a,{href:"https://www.conf42.com/Rustlang_2023_Michael_Birch_smart_contracts_indexers_crosscompilation",children:(0,a.jsx)(t.em,{children:"talk at a virtual Rust conference"})})," about some work we have done here at Aurora to enable our technology. In case you missed it, this blog post is a written version of the talk."]}),"\n",(0,a.jsx)(t.p,{children:"That talk was aimed at a more general audience, giving background about Aurora, Near, and blockchain technology in general. However, this post assumes you are already familiar with most of the Aurora/Near/blockchain background (you are here on our website, after all) and instead focuses more on the Rust side of things."}),"\n",(0,a.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(t.p,{children:"The goal of this post is to describe how you can use functional programming patterns in Rust to share a codebase between both a smart contract and an indexer. But the first question to answer is why this is desirable in the first place."}),"\n",(0,a.jsx)(t.p,{children:"Indexers provide a specialized view of the blockchain state to enable low-latency responses to particular kinds of queries. For example, block explorers will use an indexer to show the balances of all the tokens held by a user. An indexer is required to accomplish this because the on-chain information about balances is indexed in the opposite way to how the block explorer displays the information. By which I mean that on-chain each token has information about all the addresses with a non-zero balance, but the block explorer shows all the non-zero balances for a single address."}),"\n",(0,a.jsx)(t.p,{children:"Generally, indexers are specialized to follow the state of a particular contract (or class of contracts). Therefore, the code for the indexer is closely related to the code for the smart contract it follows. Thus, it would be lower developer maintenance to have a common codebase for the smart contract and its associated indexer."}),"\n",(0,a.jsx)(t.p,{children:"Additionally, sharing a codebase makes it possible to create much more powerful indexers than simply something that can respond to queries. For example, an indexer with access to the smart contract logic can simulate whole transactions off-chain to provide free and low-latency feedback to users on potential errors."}),"\n",(0,a.jsxs)(t.p,{children:["In the case of Aurora, the indexer we use for the Aurora Engine smart contract serves data that is used by ",(0,a.jsx)(t.a,{href:"/blog/spinning-up-your-own-aurora-node",children:"our RPC implementation."})," The Ethereum RPC spec includes a few methods (e.g., ",(0,a.jsx)(t.code,{children:"eth_estimateGas"}),") which require simulating transactions before submitting them to the chain. Therefore, we have a clear use for the extra indexer features that are enabled by having a shared codebase between the Aurora Engine and its indexer."]}),"\n",(0,a.jsx)(t.h2,{id:"rust-features",children:"Rust Features"}),"\n",(0,a.jsx)(t.p,{children:"To reach the goal of having a shared codebase between the Aurora Engine and an indexer for the Engine, we leverage some features of Rust."}),"\n",(0,a.jsx)(t.h3,{id:"cross-compilation",children:"Cross-Compilation"}),"\n",(0,a.jsx)(t.p,{children:"The Aurora Engine is written in Rust because it is a smart contract on Near which uses Web Assembly as its runtime. Rust has good support for Web Assembly (Wasm) as a compilation target, so it is a good language choice for writing smart contracts for Near. But, of course, it also is able to compile the same code to executable binaries for typical platforms (e.g., Linux). Compiling the same code to multiple output targets is referred to as \u201ccross-compiling\u201d."}),"\n",(0,a.jsx)(t.p,{children:"The first step to having our smart contract code also be used as an indexer is to cross-compile the same code as both Wasm and a native executable. In Rust, it is easy to install other compilation targets (the default target will be whatever platform you installed Rust on) and to specify them as the compilation target. The following commands show installing the Wasm target and compiling a project to Wasm."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:"$ rustup target add wasm32-unknown-unknown\n$ cargo build --release \u2013-target wasm32-unknown-unknown\n"})}),"\n",(0,a.jsx)(t.h3,{id:"conditional-compilation",children:"Conditional Compilation"}),"\n",(0,a.jsx)(t.p,{children:"When you start compiling code to multiple platforms, likely there will be situations where you want the implementation to differ depending on the compilation target. For example, native code can read from a local file system, whereas Wasm modules need to delegate to their host (the machine running the Wasm VM) to access state."}),"\n",(0,a.jsx)(t.p,{children:"In Rust, you can use conditional compilation to have different implementations depending on the target. In the example below, the function `foo` has different implementations depending on if the compilation target is Wasm or not."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'fn foo() {\n    #[cfg(target_arch = "wasm32")]\n    foo_for_wasm();\n\n    #[cfg(not(target_arch = "wasm32"))]\n    foo_for_generic_arch();\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["However, conditional compilation has some drawbacks. First of all, it\u2019s a little verbose, which hurts code readability. You can see in the example above that the function ",(0,a.jsx)(t.code,{children:"foo"})," is \u201cnoisier\u201d than it would be if not for the extra conditional compilation annotations. Secondly, IDEs do not handle conditional compilation especially well. They will only analyze one branch of the code at a time, and it is a little tedious to switch between which target you are asking the IDE to check."]}),"\n",(0,a.jsx)(t.p,{children:"Fortunately, we do not need to use conditional compilation very much because we can adopt coding style patterns from functional programming. The key idea is to write code that is abstract with respect to the implementation of target-specific effects such as reading/writing state. In Rust, we can accomplish this using traits and type generics."}),"\n",(0,a.jsx)(t.h3,{id:"traits-and-type-generics",children:"Traits and Type Generics"}),"\n",(0,a.jsx)(t.p,{children:"Rust\u2019s trait defines an interface. It gives the type signatures of the methods a type implementing that trait must have, but does not necessarily specify the implementation of those methods (though you are allowed to give a default implementation of a method in a trait). Consider the following example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"trait IO {\n    fn read(&self, key: &[u8]) -> Vec<u8>;\n    fn write(&mut self, key: &[u8], value: &[u8]);\n}\n\nfn get_balance<I: IO>(io: &I, user: User) -> u128 {\n    u128::from_be_bytes(&io.read(&user.id()))\n}r\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This example includes a trait with a (simplified) interface for interacting with state as well as a function with a generic type parameter. The syntax means \u201cthis function accepts any type so long as it implements ",(0,a.jsx)(t.code,{children:"IO"})," the interface\u201d. The benefit of coding in this style is that the ",(0,a.jsx)(t.code,{children:"get_balance"})," function can now be reused in any program, regardless of what compilation target it uses, so long as there is an ",(0,a.jsx)(t.code,{children:"IO"})," implementation for it. This is exactly what enables us to share a codebase between our smart contract and indexer."]}),"\n",(0,a.jsx)(t.p,{children:"In this example above, it might seem like we are going through a lot of trouble to reuse one line of code in two different places. But this approach scales. The function we share does not need to be only a single line, it could have any amount of complexity."}),"\n",(0,a.jsx)(t.p,{children:"Moreover, state access is not the only target-specific effect. We can have traits for accessing environment variables (in the blockchain context, these would be variables like the current block height, the signer of the transaction, etc) and interacting with other processes (in the blockchain context, this corresponds to calling other smart contracts)."}),"\n",(0,a.jsx)(t.p,{children:"Beyond reusability, there are other benefits to coding in this style. Code written in this way is easier to test because you can simulate the effects in-memory (for example, instead of actually reading and writing files). It is also easier to reason about this style of code. When there are no side-effects, the function signature gives you all the information you need about the function."}),"\n",(0,a.jsxs)(t.p,{children:["If a function needs access to state, then you know it will include the ",(0,a.jsx)(t.code,{children:"IO"})," trait bound, and conversely, if the state is not needed, then it will not include that bound. When you can learn so much about a function without reading its implementation body, it becomes much easier to navigate the codebase."]}),"\n",(0,a.jsx)(t.h2,{id:"application-aurora-engine",children:"Application: Aurora Engine"}),"\n",(0,a.jsxs)(t.p,{children:["The entire Aurora Engine is written in this style. For example, ",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/2.10.2/engine/src/engine.rs#L1280",children:(0,a.jsx)(t.em,{children:"here"})})," is the real version of the ",(0,a.jsx)(t.code,{children:"get_balance"})," function we showed a toy example of above. And similarly, there is a ",(0,a.jsx)(t.code,{children:"set_balance"})," ",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/2.10.2/engine/src/engine.rs#L1269",children:(0,a.jsx)(t.em,{children:"function"})}),". These two functions are composed together to make an ",(0,a.jsx)(t.code,{children:"add_balance"})," ",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/2.10.2/engine/src/engine.rs#L1258",children:(0,a.jsx)(t.em,{children:"function"})}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub fn get_balance<I: IO>(io: &I, address: &Address) -> Wei {\n    let raw = io\n        .read_u256(&address_to_key(KeyPrefix::Balance, address))\n        .unwrap_or_else(|_| U256::zero());\n    Wei::new(raw)\n}\n\npub fn set_balance<I: IO>(io: &mut I, address: &Address, balance: &Wei) {\n    io.write_storage(\n        &address_to_key(KeyPrefix::Balance, address),\n        &balance.to_bytes(),\n    );\n}\n\npub fn add_balance<I: IO>(\n    io: &mut I,\n    address: &Address,\n    amount: Wei,\n) -> Result<(), BalanceOverflow> {\n    let current_balance = get_balance(io, address);\n    let new_balance = current_balance.checked_add(amount).ok_or(BalanceOverflow)?;\n    set_balance(io, address, &new_balance);\n    Ok(())\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You can see the implementation of the ",(0,a.jsx)(t.code,{children:"IO"})," trait for both the ",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/2.10.2/engine-sdk/src/near_runtime.rs#L128",children:(0,a.jsx)(t.em,{children:"Near Runtime"})}),", and the \u201c",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/2.10.2/engine-standalone-storage/src/engine_state.rs#L82",children:(0,a.jsx)(t.em,{children:"standalone engine"})}),"\u201d which uses a ",(0,a.jsx)(t.code,{children:"rocksdb"})," instance to persist the state."]}),"\n",(0,a.jsxs)(t.p,{children:["The former is used in the Wasm artifact, which is deployed to Near as the Aurora Engine smart contract. The standalone engine is used to ",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/borealis-engine-lib/blob/v0.23.4/refiner-app/src/socket.rs#L129",children:(0,a.jsx)(t.em,{children:"implement the eth_estimateGas RPC method"})}),", and the state is populated by ",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/2.10.2/engine-standalone-storage/src/sync/mod.rs#L229",children:(0,a.jsx)(t.em,{children:"consuming Near blocks"})})," (from ",(0,a.jsx)(t.a,{href:"https://github.com/aurora-is-near/borealis-engine-lib/tree/v0.23.4#near-data-lake",children:(0,a.jsx)(t.em,{children:"Near data lake for example"})}),")."]}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"The take-home message from this post is that following the functional programming pattern of only writing business logic using abstractions of target-specific effects such as IO results in code that is easier to test, maintain, and reuse. In the particular case of Aurora, that reuse manifests as having the Aurora Engine smart contract and the indexer that serves the Aurora RPC share a codebase."})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},7507:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(9474);const o={},i=a.createContext(o);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);