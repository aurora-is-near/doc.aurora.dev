"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[3482],{137:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"crosschain/xcc/near-to-aurora/usage-examples","title":"Usage Examples","description":"Calling Uniswap from Near","source":"@site/docs/crosschain/xcc/near-to-aurora/usage-examples.md","sourceDirName":"crosschain/xcc/near-to-aurora","slug":"/crosschain/xcc/near-to-aurora/usage-examples","permalink":"/crosschain/xcc/near-to-aurora/usage-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/docs/crosschain/xcc/near-to-aurora/usage-examples.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Usage examples","title":"Usage Examples"},"sidebar":"developers","previous":{"title":"Introduction","permalink":"/crosschain/xcc/near-to-aurora/introduction"},"next":{"title":"Introduction","permalink":"/onboard/introduction"}}');var o=a(3274),r=a(7507);const s={sidebar_label:"Usage examples",title:"Usage Examples"},i=void 0,c={},l=[{value:"Calling Uniswap from Near",id:"calling-uniswap-from-near",level:2},{value:"Note for developers: workspace organization",id:"note-for-developers-workspace-organization",level:3}];function u(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"calling-uniswap-from-near",children:"Calling Uniswap from Near"}),"\n",(0,o.jsxs)(t.p,{children:["This is an example of a Near contract interacting with an EVM contract deployed on Aurora.\nIn this case the EVM contract is ",(0,o.jsx)(t.a,{href:"https://docs.uniswap.org/contracts/v3/overview",children:"Uniswap V3"}),".\nThe full Uniswap API is complex, so this example only implements one function to illustrate the pattern.\nThe function implemented in this Near contract is ",(0,o.jsx)(t.a,{href:"https://docs.uniswap.org/contracts/v3/reference/periphery/SwapRouter#exactoutputsingle",children:"exactOutputSingle"}),".\nThe ",(0,o.jsx)(t.code,{children:"exactOutputSingle"}),' function is used to perform a token swap using a single liquidity pool where the swap is constrained to give an exact amount of the "output"\ntoken within some price limitation of the "input" token.\nThe return value of ',(0,o.jsx)(t.code,{children:"exactOutputSingle"})," is the amount of input token spent to make the swap."]}),"\n",(0,o.jsxs)(t.p,{children:["The Near contract works as a proxy with a method called ",(0,o.jsx)(t.code,{children:"exact_output_single"})," that takes the same input as Uniswap's ",(0,o.jsx)(t.code,{children:"exactOutputSingle"}),".\nThe ",(0,o.jsx)(t.code,{children:"exact_output_single"})," function returns a ",(0,o.jsx)(t.code,{children:"Promise"})," because under the hood it is making a Near cross-contract call to the Aurora EVM where the Uniswap code is deployed.\nThis contract attaches a callback to the promise so that it can interpret the output obtained from Aurora and present it in a more Near-friendly way (i.e. encoding it JSON instead of a binary format)."]}),"\n",(0,o.jsxs)(t.p,{children:['This contract must own the assets it is using to swap inside the EVM.\nTherefore a prerequisite to using this contract is to transfer assets to its EVM "implicit address".\nSee the main documentation in ',(0,o.jsx)(t.code,{children:"docs/AuroraFromNear.md"})," for more information about this concept."]}),"\n",(0,o.jsx)(t.h3,{id:"note-for-developers-workspace-organization",children:"Note for developers: workspace organization"}),"\n",(0,o.jsxs)(t.p,{children:["This example is organized into two crates: the contract that would be deployed to a Near network, and a crate for integration testing of the contract.\nThis layout was chosen as opposed to making the integration tests part of a ",(0,o.jsx)(t.a,{href:"https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-directory",children:"tests directory"}),"\nin the contract crate because the purpose of the integration tests is to test the compiled Wasm (i.e. binary) artifact of the contract as opposed to testing it as a Rust library.\nMy understanding of the ",(0,o.jsx)(t.a,{href:"https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests-for-binary-crates",children:"note in the Rust book about the tests directory"}),"\nis that it is meant for testing library integrations as opposed to binary integrations.\nThus I chose to factor the integration tests out as an entirely separate crate.\nYou may or may not make a different choice in your own projects, and that's ok."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:" /// Proxy for [exactOutputSingle](https://docs.uniswap.org/contracts/v3/reference/periphery/SwapRouter#exactoutputsingle).\n    /// Calls the `exact_output_single` function of a Uniswap router contract deployed on Aurora.\n    pub fn exact_output_single(&self, params: SerializableExactOutputSingleParams) -> Promise {\n        let params: ExactOutputSingleParams = params.try_into().unwrap();\n        let evm_token = ethabi::Token::Tuple(vec![\n            ethabi::Token::Address(params.token_in.raw()),\n            ethabi::Token::Address(params.token_out.raw()),\n            ethabi::Token::Uint(params.fee.into()),\n            ethabi::Token::Address(params.recipient.raw()),\n            ethabi::Token::Uint(params.deadline),\n            ethabi::Token::Uint(params.amount_out),\n            ethabi::Token::Uint(params.amount_in_max),\n            ethabi::Token::Uint(params.price_limit),\n        ]);\n        let evm_input = ethabi::encode(&[evm_token]);\n        let aurora_call_args = CallArgs::V1(FunctionCallArgsV1 {\n            contract: self.uniswap,\n            input: [\n                EXACT_OUTPUT_SINGLE_SELECTOR.as_slice(),\n                evm_input.as_slice(),\n            ]\n            .concat(),\n        });\n        aurora_sdk::aurora_contract::ext(self.aurora.clone())\n            .with_unused_gas_weight(3)\n            .call(aurora_call_args)\n            .then(Self::ext(env::current_account_id()).parse_exact_output_single_result())\n    }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["You can find the full repo of this example on the GitHub ",(0,o.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-contracts-sdk/tree/main/examples/uniswap-from-near",children:"here"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},7507:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>i});var n=a(9474);const o={},r=n.createContext(o);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);