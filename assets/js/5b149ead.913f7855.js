"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[4628],{6170:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=n(3274),r=n(7507);const a={title:"Demystifying Transaction Failures",description:"Getting transaction receipts and parsing Aurora Engine's transaction statuses",date:"2023-03-30",authors:["slava"],tags:["tips_and_tricks"],image:"https://www.datocms-assets.com/95026/1682082259-dtf-article-cover.png"},o=void 0,i={permalink:"/blog/demystifying-transaction-failures",editUrl:"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/blog/demystifying-transaction-failures.md",source:"@site/blog/demystifying-transaction-failures.md",title:"Demystifying Transaction Failures",description:"Getting transaction receipts and parsing Aurora Engine's transaction statuses",date:"2023-03-30T00:00:00.000Z",tags:[{inline:!1,label:"Tips & Tricks",permalink:"/blog/tags/tips_and_tricks",description:"Short posts about tech for devs on Aurora"}],readingTime:2.533333333333333,hasTruncateMarker:!0,authors:[{name:"Slava Karkunov",title:"DevRel",socials:{x:"https://x.com/apocnab",github:"https://github.com/karkunow",linkedin:"https://www.linkedin.com/in/karkunov/"},imageURL:"https://www.datocms-assets.com/95026/1677167398-photo_2022-12-02-14-55-03.jpeg",key:"slava",page:null}],frontMatter:{title:"Demystifying Transaction Failures",description:"Getting transaction receipts and parsing Aurora Engine's transaction statuses",date:"2023-03-30",authors:["slava"],tags:["tips_and_tricks"],image:"https://www.datocms-assets.com/95026/1682082259-dtf-article-cover.png"},unlisted:!1,prevItem:{title:"How to get NEAR transaction from the Aurora\u2019s one?",permalink:"/blog/convert-aurora-transaction-into-near-s-one"}},c={authorsImageUrls:[void 0]},l=[{value:"<em>Errors and Explorer</em>",id:"errors-and-explorer",level:3},{value:"Aurora Helpers Tool",id:"aurora-helpers-tool",level:3},{value:"Error Types",id:"error-types",level:3},{value:"Calling NEAR RPC",id:"calling-near-rpc",level:3},{value:"Final Thoughts",id:"final-thoughts",level:3}];function d(e){const t={a:"a",br:"br",code:"code",em:"em",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"In this blog post, I want to discuss transaction failures on the Aurora blockchain and guide developers in understanding what exactly has happened with your transaction."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["tl;dr: just use ",(0,s.jsx)(t.a,{href:"https://aurora-helpers.vercel.app/aurora_to_near",children:(0,s.jsx)(t.strong,{children:"Aurora Helpers dApp"})})," and get the Near transaction error code there"]})}),"\n",(0,s.jsx)(t.h3,{id:"errors-and-explorer",children:(0,s.jsx)(t.em,{children:"Errors and Explorer"})}),"\n",(0,s.jsxs)(t.p,{children:["One common challenge that developers may face when dealing with transaction failures is the small amount of information provided by ",(0,s.jsx)(t.a,{href:"https://explorer.mainnet.aurora.dev/",children:(0,s.jsx)(t.em,{children:"Block Explorer"})}),". While some errors may be clearly displayed in it, and at least give some clue about the problem:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1679334253-screenshot-2023-03-16-at-20-55-40.png",alt:""})}),"\n",(0,s.jsx)(t.p,{children:"Others may not provide any information at all, leaving developers wondering what went wrong and how to fix it:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1679334351-screenshot-2023-03-16-at-20-56-46.png",alt:""})}),"\n",(0,s.jsxs)(t.p,{children:["Let's take one of those transactions which fai ",(0,s.jsx)(t.code,{children:"Error: Unknown"}),", e.g., ",(0,s.jsx)(t.code,{children:"0x36e2339784004c5dd40df74e663f1fe6683705a8ad665a05a9ad0aa4e11b559b"}),":"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1679336814-screenshot-2023-03-20-at-18-25-56.png",alt:""})}),"\n",(0,s.jsx)(t.h3,{id:"aurora-helpers-tool",children:"Aurora Helpers Tool"}),"\n",(0,s.jsxs)(t.p,{children:["In the case of an ",(0,s.jsx)(t.code,{children:"Error: Unknown,"})," you just could go to the ",(0,s.jsx)(t.a,{href:"https://aurora-helpers.vercel.app/aurora_to_near",children:(0,s.jsx)(t.em,{children:"Aurora Helpers dApp"})})," and enter your transaction hash there to get the corresponding Near Receipt/Transaction:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1679324662-screenshot-2023-03-20-at-15-03-32.png",alt:""})}),"\n",(0,s.jsx)(t.p,{children:"Below you will see the transaction status:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1679350478-screenshot-2023-03-20-at-22-14-25.png",alt:""})}),"\n",(0,s.jsx)(t.p,{children:"That is it. The task is solved. You can see in Aurora Helpers directly what this status means, but we will talk a little more about those codes in the next section."}),"\n",(0,s.jsx)(t.h3,{id:"error-types",children:"Error Types"}),"\n",(0,s.jsxs)(t.p,{children:["Those ",(0,s.jsx)(t.code,{children:"07 03"})," numbers correspond to the ",(0,s.jsx)(t.code,{children:"status"})," field of the Aurora Engine's transaction. The First number indicates the",(0,s.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/pull/299/files#diff-a0e4fe79c7aa101e4b4e969318e18bb3854f0f8607e4b56d5665e131f98fdfa8R116",children:"Aurora Engine API version"}),". And the second one corresponds to the ",(0,s.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/a00df8e7d83ae49c035348111cc89be28cb93dab/engine-types/src/parameters/engine.rs#L19-L26",children:"statuses"})," which could transactions have inside the Engine after execution."]}),"\n",(0,s.jsx)(t.p,{children:"Let's compile them into the list below:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"00 \u2013 Succeed: transaction has been executed successfully."}),"\n",(0,s.jsx)(t.li,{children:"01 \u2013 Revert: transaction has been reverted, most likely because of internal contract terms."}),"\n",(0,s.jsx)(t.li,{children:"02 \u2013 OutOfGas: execution ran out of gas."}),"\n",(0,s.jsx)(t.li,{children:"03 \u2013 OutOfFund: not enough funds to start the execution."}),"\n",(0,s.jsx)(t.li,{children:"04 \u2013OutOfOffset: an opcode accesses external information, but the request exceeds the offset limit."}),"\n",(0,s.jsx)(t.li,{children:"05 \u2013 CallTooDeep: call stack is too deep."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"We can create the enum map inside our code to convert easily between codes and error names:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const TxErrors = {\n  Succeed: 0,\n  Revert: 1,\n  OutOfGas: 2,\n  OutOfFund: 3,\n  OutOfOffset: 4,\n  CallTooDeep: 5\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You can use better-styled enums by using Enumify or just using Object.Freeze(), if you're interested \u2013 read more ",(0,s.jsx)(t.a,{href:"https://masteringjs.io/tutorials/fundamentals/enum",children:"here"}),". But first, let's find out how to get this status field using a NEAR RPC request. We will use a simple Node.js code snippet to do this."]}),"\n",(0,s.jsx)(t.h3,{id:"calling-near-rpc",children:"Calling NEAR RPC"}),"\n",(0,s.jsxs)(t.p,{children:["First, we will need the ",(0,s.jsx)(t.code,{children:"getNearTxHash()"})," function from this article to get the corresponding NEAR transaction hash: ",(0,s.jsx)(t.a,{href:"/blog/convert-aurora-transaction-into-near-s-one",children:"How to get NEAR transaction from the Aurora\u2019s one?"}),". We are assuming that this code is already written in your code editor.",(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.br,{}),"\n","Second, we will use this helper function to convert ",(0,s.jsx)(t.code,{children:"base64"})," encoding into ",(0,s.jsx)(t.code,{children:"decimal"})," format:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"function base64ToDecimal(str) {\n   const text = Buffer.from(str, 'base64').toString('ascii');\n   \n   const decimalArray = []\n\n   for (let i in text) {\n     decimalArray.push(text.charAt(i).charCodeAt(0))\n   }\n \n   return decimalArray;\n }\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We're ready to query the NEAR RPC node (you can get endpoints ",(0,s.jsx)(t.a,{href:"https://docs.near.org/api/rpc/setup",children:"here"}),") using the Axios HTTP client. Notice that we're using ",(0,s.jsx)(t.code,{children:"archival-rpc"})," here to query also historical data (older than  ",(0,s.jsx)(t.a,{href:"https://docs.near.org/concepts/basics/epoch",children:"epochs"})," or ~2.5 days):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const getTransactionStatus = async () => {\n   const hash = await getNearTxHash();\n   const nearRPC = 'https://archival-rpc.mainnet.near.org';\n\n   const response = await axios.post(nearRPC, {\n       jsonrpc: '2.0',\n       method: 'tx',\n       params: [hash, 'aurora'],\n       id: 1,\n   })\n\n   const status = response?.data?.result?.status?.SuccessValue\n   const sliced = base64ToDecimal(status).slice(0, 2));\n   /*just for demonstration purposes*/\n   console.log('status', status);\n   console.log('status', base64ToDecimal(status));\n   console.log('status', sliced);\n   return sliced;\n }\n\n getTransactionStatus();\n"})}),"\n",(0,s.jsx)(t.p,{children:"By running the code above you will get this output:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"status BwMAAAAAAAAAAAAAAAA=\nstatus [\n  7, 3, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0,\n  0, 0\n]\nstatus [ 7, 3 ]\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.br,{}),"\n","As you can see, we have a ",(0,s.jsx)(t.code,{children:"base64"})," encoded status field in the first line. Then we decode it into decimals and, after it \u2013 slice the first two numbers (others are not in use right now). They're precisely the ones we've been expecting! We have an ",(0,s.jsx)(t.code,{children:"OutOfFund"})," error. Now we can use the JSON map from the beginning of the article ",(0,s.jsx)(t.code,{children:"TxErrors"})," to convert transaction status into a readable format:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:'getTransactionStatus().then((status) => {\n  for (var key in TxErrors) {\n      if (TxErrors[key] == status[1]) {\n          console.log("Transaction has status: " + key);\n      }\n  }\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"final-thoughts",children:"Final Thoughts"}),"\n",(0,s.jsxs)(t.p,{children:["In this post, we've learned how to get the info about Aurora Engine transactions errors which sometimes could be hidden from the naked eye inside the corresponding NEAR transaction.",(0,s.jsx)(t.br,{}),"\n","And all of that was done purely with JS code.",(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.br,{}),"\n","I hope you had fun while reading this! Leave us your feedback, comments, and thoughts below."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7507:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(9474);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);