"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[4276],{21060:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var i=s(69397),n=s(13274),r=s(77507);const a={title:"Aurora Chains: Code Overview",description:"Discover the source code for Aurora Chains: how fixed gas cost and access control are achieved",date:"2023-05-19",authors:["slava"],tags:["core_tech"],image:"https://www.datocms-assets.com/95026/1701394771-ac4.png"},o=void 0,h={authorsImageUrls:[void 0]},l=[{value:"Where is it?",id:"where-is-it",level:3},{value:"Aurora Chain Module Imports",id:"aurora-chain-module-imports",level:3},{value:"Parameters.rs",id:"parametersrs",level:3},{value:"Whitelist Kinds",id:"whitelist-kinds",level:4},{value:"Whitelist Args",id:"whitelist-args",level:4},{value:"Whitelists",id:"whitelists",level:3},{value:"Imports",id:"imports",level:4},{value:"Whitelist Type",id:"whitelist-type",level:4},{value:"Storage and Key functions",id:"storage-and-key-functions",level:4},{value:"Aurora Chain Module",id:"aurora-chain-module",level:3},{value:"Whitelists",id:"whitelists-1",level:4},{value:"Fixed Gas",id:"fixed-gas",level:4},{value:"Conclusions",id:"conclusions",level:3}];function d(e){const t={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"The main goal of this article is to understand the Aurora Chain code. In a future post, we will discuss how it embellishes the Aurora Engine and how the advantages of an Aurora Chain correspond to different parts of code and Aurora architecture."}),"\n",(0,n.jsxs)(t.p,{children:["For now, just recall that Aurora Chain is just the Aurora Engine with a couple of new features on top of it: see ",(0,n.jsx)(t.code,{children:"What are Aurora Chains?"})," section in ",(0,n.jsx)(t.a,{href:"/blog/aurora-chains-demo",children:"Aurora Chains: Walkthrough"}),". Let's take a closer look at the ",(0,n.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine",children:"Aurora Engine repo"})," to find a code for Aurora Chain. You will see sometimes Aurora Chains called Silos. The meaning is the same. It is just a more user-friendly renaming of the technology. The Rust module for Aurora Chain is actually called ",(0,n.jsx)(t.code,{children:"silo"}),".",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.br,{}),"\n","The source code of Aurora Chain is inside the pull request (PR) ",(0,n.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/pull/746",children:"#746: feat: add possibility to use fixed gas cost (silo)."})," The first question that comes to mind is why it is called so? The clue is in the description right away and leads us to the first feature:"]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.em,{children:["The PR adds the possibility to set fixed gas cost per EVM transaction. The feature could be switched on by calling ",(0,n.jsx)(t.code,{children:"set_fixed_gas_cost"}),"."]})}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The second feature is access control, which is realized with the four types of whitelists to regulate the rights to deploy code and submit transactions."}),"\n",(0,n.jsx)(t.p,{children:"Now, let's look closer at the PR itself and what Aurora Chain actually is."}),"\n",(0,n.jsx)(t.h3,{id:"where-is-it",children:"Where is it?"}),"\n",(0,n.jsx)(t.p,{children:"First, we take a look at the folders in which developers have changed files:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1684180353-screenshot-2023-05-15-at-20-52-18.png",alt:""})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"engine-standalone-storage"})," folder shouldn't worry you: it is kinda an IO for the Engine, definitely not the main part of it. As for the ",(0,n.jsx)(t.code,{children:"engine-tests"})," and ",(0,n.jsx)(t.code,{children:"engine-types,"})," those are not critical for understanding, but they can give you some insights about the details because \u2013 as we all know \u2013 tests and types are foundational for a nicely working code. So, the only folder left is ",(0,n.jsx)(t.code,{children:"engine"})," and that is the right guess to look into it:"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1684180726-screenshot-2023-05-15-at-20-58-36.png",alt:""})}),"\n",(0,n.jsxs)(t.p,{children:["This folder is the heart of the repo and the Aurora itself. Inside we will see some files of the Engine changed, among which ",(0,n.jsx)(t.code,{children:"engine.rs"})," , and ",(0,n.jsx)(t.code,{children:"lib.rs"})," are the key ones. Also, notice the ",(0,n.jsx)(t.code,{children:"src/silo"})," folder. Which is the thing we were looking for!"]}),"\n",(0,n.jsx)(t.h3,{id:"aurora-chain-module-imports",children:"Aurora Chain Module Imports"}),"\n",(0,n.jsxs)(t.p,{children:["Aurora Engine is written in Rust, the native language for the NEAR contracts. In our case, the main entry point to the Aurora Chain module is the ",(0,n.jsx)(t.code,{children:"mod.rs"})," file, which is the core part of the module. In its turn, it also relies on two submodules ",(0,n.jsx)(t.code,{children:"parameters.rs"})," and ",(0,n.jsx)(t.code,{children:"whitelist.rs"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use parameters::{WhitelistArgs, WhitelistKindArgs, WhitelistStatusArgs};\nuse whitelist::Whitelist;\npub use whitelist::WhitelistKind;\n\npub mod parameters;\nmod whitelist;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Let's start with reviewing the ",(0,n.jsx)(t.code,{children:"parameters.rs"})," file."]}),"\n",(0,n.jsx)(t.h3,{id:"parametersrs",children:"Parameters.rs"}),"\n",(0,n.jsxs)(t.p,{children:["This file contains all of the important function arguments' structs and enums for Aurora Chain. The reason to have those is to decouple the arguments from the implementation: it will be easier to change them in one place later and leave function implementations as is. The file starts importing some useful types, ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Ad_hoc_polymorphism",children:"traits"})," , and the ",(0,n.jsx)(t.code,{children:"WhitelistKind"})," enum:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use aurora_engine_types::account_id::AccountId; // corresponds to NEAR account\nuse aurora_engine_types::types::{Address, Wei}; // Aurora Address, and Wei for ETH\nuse borsh::{BorshDeserialize, BorshSerialize}; // borsh traits\n\nuse crate::silo::whitelist::WhitelistKind; // type of the whitelist\n"})}),"\n",(0,n.jsx)(t.h4,{id:"whitelist-kinds",children:"Whitelist Kinds"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"WhitelistKind"})," can be one of the four types, you can find the definition in ",(0,n.jsx)(t.code,{children:"whitelist.rs"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub enum WhitelistKind {\n    /// The whitelist of this type is for storing NEAR accounts. \n    /// Accounts stored in this whitelist have an admin role. \n    /// The admin role allows to add new admins and add new entities\n    /// (`AccountId` and `Address`) to whitelists.\n    /// This role allows to deploy of EVM code.\n    Admin = 0x0,\n    /// The whitelist of this type is for storing EVM addresses. \n    /// Addresses included in this whitelist can deploy EVM code.\n    EvmAdmin = 0x1,\n    /// The whitelist of this type is for storing NEAR accounts.\n    /// Accounts included in this whitelist can submit transactions.\n    Account = 0x2,\n    /// The whitelist of this type is for storing EVM addresses. \n    /// Addresses included in this whitelist can submit transactions.\n    Address = 0x3,\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["We can whitelist users by a NEAR account or Aurora address. EVM address is their own one, but with the NEAR account situation is trickier because it is the one from which the engine transactions go to the NEAR node (i.e., it is a relayer's NEAR account). This account will pay for the NEAR gas on behalf of the user.",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.br,{}),"\n","To understand this part better, take a look at this picture which illustrates how Aurora works in general:"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1682422805-screenshot-2023-04-25-at-12-39-54.png",alt:""})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.br,{}),"\n","The RPC in the picture above is our Relayer instance (it includes ",(0,n.jsx)(t.a,{href:"https://github.com/aurora-is-near/standalone-rpc",children:"RPC, relayer, and refiner"}),", but that is a matter for another article). At the triangle base, we have NEAR Node and Engine Contract. So it is the address of the top vertex we're filtering with the account's whitelists.",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.br,{}),"\n","To continue with the whitelist kinds, we have another dimension to whitelist users: either to allow the deployment of new contracts or allow them to transact. We can make this really clear by using this table (with the exception, that an Admin can also edit whitelists):"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://www.datocms-assets.com/95026/1684454005-screenshot-2023-05-19-at-00-53-10.png",alt:""})}),"\n",(0,n.jsx)(t.h4,{id:"whitelist-args",children:"Whitelist Args"}),"\n",(0,n.jsxs)(t.p,{children:["The main part of the ",(0,n.jsx)(t.code,{children:"parameters.rs"})," is related to the whitelists args of different types:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub enum WhitelistArgs {\n    WhitelistAddressArgs(WhitelistAddressArgs),\n    WhitelistAccountArgs(WhitelistAccountArgs),\n} // Enum to separate Address vs Account whitelist args.\n\npub struct WhitelistAddressArgs {\n    pub kind: WhitelistKind,\n    pub address: Address,\n} // This one contains kind (0x1, 0x3) + Aurora address.\n\npub struct WhitelistAccountArgs {\n    pub kind: WhitelistKind,\n    pub account_id: AccountId,\n} // Kind (0x0, 0x2) + NEAR account\n\npub struct WhitelistStatusArgs {\n    pub kind: WhitelistKind,\n    pub active: bool,\n} // Status to track if the whitelist is active or not.\n  // If not - it won't be used by a Aurora Chain at all.\n\npub struct WhitelistKindArgs {\n    pub kind: WhitelistKind,\n} // just another parametrization to track the kind.\n"})}),"\n",(0,n.jsxs)(t.p,{children:["There is also one small test at the end of the file with the whitelist args ",(0,n.jsx)(t.a,{href:"https://github.com/near/borsh-rs",children:"borsh serialization"}),". I will skip ",(0,n.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/0de3198c2d602a8f23d5ea9797a6ab4c921e6f52/engine/src/silo/parameters.rs#L60",children:"the code"})," for brevity."]}),"\n",(0,n.jsx)(t.h3,{id:"whitelists",children:"Whitelists"}),"\n",(0,n.jsxs)(t.p,{children:["Let's move on to the second file: ",(0,n.jsx)(t.code,{children:"whitelists.rs"}),". We have already seen a part of it above \u2013 ",(0,n.jsx)(t.code,{children:"WhitelistKind"})," enum."]}),"\n",(0,n.jsx)(t.h4,{id:"imports",children:"Imports"}),"\n",(0,n.jsx)(t.p,{children:"Now, let's take a look at what imports are inside the file:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use aurora_engine_sdk::io::{StorageIntermediate, IO};\nuse aurora_engine_types::storage::{bytes_to_key, KeyPrefix};\nuse aurora_engine_types::AsBytes;\nuse borsh::{BorshDeserialize, BorshSerialize};\n\nuse crate::prelude::Vec;\n//seen those before, right?\nuse crate::silo::parameters::{WhitelistKindArgs, WhitelistStatusArgs};\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Aurora Engine SDK is a ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Foreign_function_interface",children:"FFI way"})," to write a NEAR contract in Rust, which deserves a separate article, so we won't concentrate on it. We're importing it to communicate with the ",(0,n.jsx)(t.a,{href:"https://docs.near.org/concepts/storage/data-storage",children:"NEAR storage"}),", which is just a key-value database. To generate a key for the data to store, we use ",(0,n.jsx)(t.code,{children:"bytes_to_key"})," function and ",(0,n.jsx)(t.code,{children:"KeyPrefix"}),". We also have ",(0,n.jsx)(t.code,{children:"AsBytes"})," trait to help us interpret things as an array of bytes."]}),"\n",(0,n.jsx)(t.h4,{id:"whitelist-type",children:"Whitelist Type"}),"\n",(0,n.jsx)(t.p,{children:"Let's overview the Whitelist type now:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'const STATUS: &[u8] = b"LIST_STATUS";\n\nimpl<I> Whitelist<I> where I: IO + Copy {\n  /// Constructor.\n  pub const fn init(io: &I, kind: WhitelistKind) -> Self {...}\n\n  /// Create keys for storage.\n  fn key(&self, value: &[u8]) -> Vec<u8> {...}\n\n  /// Status.\n  pub fn enable(&mut self) {...} /// set STATUS key in storage to true.\n  pub fn disable(&mut self) {...} /// set STATUS key in storage to false.\n  pub fn is_enabled(&self) -> bool {...} /// get STATUS key from storage.\n  \n  /// Entries.\n  pub fn add<A: AsBytes + ?Sized>(&mut self, element: &A) {...}\n  pub fn remove<A: AsBytes + ?Sized>(&mut self, element: &A) {...}\n  pub fn is_exist<A: AsBytes + ?Sized>(&self, element: &A) -> bool {...}\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["I have also omitted the bodies for brevity, overall they're just working with storage and get/set the key-value pairs. As you can see, we can separate methods in the Whitelist into two main groups: ",(0,n.jsx)(t.code,{children:"Status"})," and ",(0,n.jsx)(t.code,{children:"Entries"}),'. The first group is used to enable or disable the whitelist and check its status. The status "field" tells us if the whitelist will be used by a Aurora Chain or not. The special prefix, defined by the ',(0,n.jsx)(t.code,{children:"STATUS"})," variable, is used to produce a key to store this field."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"The Entries"})," group is used to add, remove or check the inclusion of an element into the whitelist. Which can be anything, defined by a type ",(0,n.jsx)(t.code,{children:"A"})," here, implementing ",(0,n.jsx)(t.code,{children:"AsBytes"})," trait."]}),"\n",(0,n.jsx)(t.h4,{id:"storage-and-key-functions",children:"Storage and Key functions"}),"\n",(0,n.jsxs)(t.p,{children:["Whitelist is also parametrized by a type ",(0,n.jsx)(t.code,{children:"I:IO"})," to allow different ways of IO interactions. Notice that it is a special kind of trait ",(0,n.jsx)(t.code,{children:"IO"})," and not ",(0,n.jsx)(t.code,{children:"std::io"})," . ",(0,n.jsx)(t.code,{children:"IO"})," trait is part of Aurora Engine SDK, created to write NEAR contracts with FFI, so it works with key-value storages (like NEAR storage)."]}),"\n",(0,n.jsxs)(t.p,{children:["That is the reason why the ",(0,n.jsx)(t.code,{children:"key"})," function is the core of the Whitelist structure: because it heavily relies on storage. Let's take a closer look at it:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"fn key(&self, value: &[u8]) -> Vec<u8> {\n    let mut bytes = Vec::with_capacity(1 + value.len());\n\n    bytes.push(u8::from(self.kind));\n    bytes.extend_from_slice(value);\n    bytes_to_key(KeyPrefix::Whitelist, &bytes)\n}\n\n/// Included this one to demonstrate the usage of `key` function.\npub fn add<A: AsBytes + ?Sized>(&mut self, element: &A) {\n    let key = self.key(element.as_bytes());\n    self.io.write_storage(&key, &[]);\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["As you can see, it is based upon the ",(0,n.jsx)(t.code,{children:"bytes_to_key"})," function, and joins the kind prefix byte to the value (in bytes) and adds a special ",(0,n.jsx)(t.code,{children:"KeyPrefix"})," for Whitelist used to differentiate different parts of storage in Aurora Engine."]}),"\n",(0,n.jsxs)(t.p,{children:["The last part of the file includes two functions to operate with the whitelist status, but using ",(0,n.jsx)(t.code,{children:"WhitelistStatusArgs"}),", which currently includes ",(0,n.jsx)(t.code,{children:"active : bool"})," field and ",(0,n.jsx)(t.code,{children:"WhitelistKind"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"/// Set status of the whitelist.\npub fn set_whitelist_status<I: IO + Copy>(io: &I, args: &WhitelistStatusArgs) {\n    let mut list = Whitelist::init(io, args.kind);\n    if args.active {\n        list.enable();\n    } else {\n        list.disable();\n    }\n}\n\n/// Get status of the whitelist.\npub fn get_whitelist_status<I: IO + Copy>(io: &I, args: &WhitelistKindArgs) -> WhitelistStatusArgs {\n    WhitelistStatusArgs {\n        kind: args.kind,\n        active: Whitelist::init(io, args.kind).is_enabled(),\n    }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"These are helpful to operate on any kind of the Whitelist without having an instance of it."}),"\n",(0,n.jsx)(t.h3,{id:"aurora-chain-module",children:"Aurora Chain Module"}),"\n",(0,n.jsxs)(t.p,{children:["We can divide the public functions of this module into two groups: ",(0,n.jsx)(t.code,{children:"Whitelists"})," and ",(0,n.jsx)(t.code,{children:"Fixed Gas"}),". The first is responsible for editing whitelists and checking the user rights. And the second one is for storing the fixed gas price for transactions inside the Aurora Chain."]}),"\n",(0,n.jsx)(t.h4,{id:"whitelists-1",children:"Whitelists"}),"\n",(0,n.jsxs)(t.p,{children:["Let's start with the Whitelists. This group can also be divided into 3 subgroups: Entries, Status, and Rights. The ",(0,n.jsx)(t.code,{children:"Entries"})," subgroup is about adding/removing entries from the whitelists:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub fn add_entry_to_whitelist<I: IO + Copy>(io: &I, args: &WhitelistArgs) {...}\npub fn add_entry_to_whitelist_batch<I: IO + Copy, A: IntoIterator<Item = WhitelistArgs>> {...}\npub fn remove_entry_from_whitelist<I: IO + Copy>(io: &I, args: &WhitelistArgs) {...}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The second one, ",(0,n.jsx)(t.code,{children:"Status"}),", is to get/set the status of the whitelists:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub fn set_whitelist_status<I: IO + Copy>(io: &I, args: &WhitelistStatusArgs) {...}\npub fn get_whitelist_status<I: IO + Copy>(io: &I, args: &WhitelistKindArgs) -> WhitelistStatusArgs {...}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["And the last one, ",(0,n.jsx)(t.code,{children:"Rights"}),", is the most interesting one:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"/// Check if the calling user is in Admin whitelist and owner of the Engine contract.\npub fn assert_admin<I: IO + Env + Copy>(io: &I) -> Result<(), EngineErrorKind> {...}\n\n/// Check if user has rights to deploy EVM code (EVMAdmin and/or Admin whitelists).\npub fn is_allow_deploy<I: IO + Copy>(io: &I, account: &AccountId, address: &Address) -> bool {...}\n\n/// Check if user has rights to submit transaction (Address and/or Account whitelists entry).\npub fn is_allow_submit<I: IO + Copy>(io: &I, account: &AccountId, address: &Address) -> bool {...}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Why? Because it is the first place in the code where we see that NEAR Accounts whitelists act in pairs with the EVM addresses ones. If we take a look into ",(0,n.jsx)(t.code,{children:"is_allow_deploy"})," function:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub fn is_allow_deploy<I: IO + Copy>(io: &I, account: &AccountId, address: &Address) -> bool {\n    let admin_list = Whitelist::init(io, WhitelistKind::Admin);\n    let evm_admin_list = Whitelist::init(io, WhitelistKind::EvmAdmin);\n\n    (!admin_list.is_enabled() || admin_list.is_exist(account))\n        && (!evm_admin_list.is_enabled() || evm_admin_list.is_exist(address))\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["It has checks for both accounts and addresses and the reason for that is that EVM address signs the EVM transaction and afterwards the relayer must wrap it into the NEAR transaction and sign it with its NEAR account \u2013 as we have discussed above \u2013 while talking about the ",(0,n.jsx)(t.code,{children:"WhitelistKind"}),"."]}),"\n",(0,n.jsx)(t.h4,{id:"fixed-gas",children:"Fixed Gas"}),"\n",(0,n.jsxs)(t.p,{children:["This group is quite simple, and just stores the ",(0,n.jsx)(t.code,{children:"fixed_gas_cost"})," field or retrieves it from storage:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'/// storage utilities.\nconst GAS_COST_KEY: &[u8] = b"GAS_COST_KEY";\nfn fixed_gas_cost_key() -> Vec<u8> {...}\n\n/// get/set fixed gas cost.\npub fn get_fixed_gas_cost<I: IO>(io: &I) -> Option<Wei> {}\npub fn set_fixed_gas_cost<I: IO>(io: &mut I, cost: Option<Wei>) {}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The price is used inside the Aurora Engine in the ",(0,n.jsx)(t.code,{children:"submit"})," function ",(0,n.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/0de3198c2d602a8f23d5ea9797a6ab4c921e6f52/engine/src/engine.rs#L863",children:"here"})," , and the ",(0,n.jsx)(t.code,{children:"charge_gas"})," function ",(0,n.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/0de3198c2d602a8f23d5ea9797a6ab4c921e6f52/engine/src/engine.rs#L438",children:"here"}),", while submitting the EVM transaction to the engine. We will discuss this part of the code with more detail in our next post about Aurora Chains.",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.br,{}),"\n","The ",(0,n.jsx)(t.code,{children:"fixed_gas_cost"})," could be set by a Aurora Chain admin interacting directly with an Engine contact on the NEAR network and calling ",(0,n.jsx)(t.code,{children:"set_fixed_gas_cost"}),"method ",(0,n.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/0de3198c2d602a8f23d5ea9797a6ab4c921e6f52/engine/src/lib.rs#L1080",children:"here"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"conclusions",children:"Conclusions"}),"\n",(0,n.jsxs)(t.p,{children:["We've overviewed one pull request introducing Aurora Chains within the Aurora Engine repo. Now we know that inside the Aurora Chain, we have access control and fixed gas cost parts hidden. We will discuss the outer connections of the Aurora Chains in articles to come. We will also cover how the methods of the Aurora Chain impact the mechanics of the EVM itself.",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.br,{}),"\n","Thanks for reading!"]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},77507:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var i=s(79474);const n={},r=i.createContext(n);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),i.createElement(r.Provider,{value:t},e.children)}},69397:e=>{e.exports=JSON.parse('{"permalink":"/blog/aurora-chains-code-overview","editUrl":"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/blog/aurora-chains-code-overview.md","source":"@site/blog/aurora-chains-code-overview.md","title":"Aurora Chains: Code Overview","description":"Discover the source code for Aurora Chains: how fixed gas cost and access control are achieved","date":"2023-05-19T00:00:00.000Z","tags":[{"inline":false,"label":"Core Tech","permalink":"/blog/tags/core_tech","description":"Posts about core technologies on Aurora"}],"readingTime":7.446666666666666,"hasTruncateMarker":true,"authors":[{"name":"Slava Karkunov","title":"DevRel","socials":{"x":"https://x.com/apocnab","github":"https://github.com/karkunow","linkedin":"https://www.linkedin.com/in/karkunov/"},"imageURL":"https://www.datocms-assets.com/95026/1677167398-photo_2022-12-02-14-55-03.jpeg","key":"slava","page":null}],"frontMatter":{"title":"Aurora Chains: Code Overview","description":"Discover the source code for Aurora Chains: how fixed gas cost and access control are achieved","date":"2023-05-19","authors":["slava"],"tags":["core_tech"],"image":"https://www.datocms-assets.com/95026/1701394771-ac4.png"},"unlisted":false,"prevItem":{"title":"Spinning up your own Aurora node","permalink":"/blog/spinning-up-your-own-aurora-node"},"nextItem":{"title":"Building a game using Near, Aurora and BOS","permalink":"/blog/building-a-game-using-near-aurora-and-bos"}}')}}]);