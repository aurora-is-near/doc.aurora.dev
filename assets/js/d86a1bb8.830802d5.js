"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[4967],{7701:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var n=o(3274),a=o(7507);const s={title:"Contract Callbacks in XCC",description:"In this post we focus on the need to refund tokens to a user in the event of an error. This will reveal a bit of a \u201cgotcha\u201d which developers new to the XCC may come across, and we\u2019ll discuss how to overcome it",date:"2023-11-17",authors:["michael"],tags:["tutorials"],image:"https://www.datocms-assets.com/95026/1700215626-xcc-cc.png"},r=void 0,c={permalink:"/blog/contract-callbacks-in-xcc",editUrl:"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/blog/contract-callbacks-in-xcc.md",source:"@site/blog/contract-callbacks-in-xcc.md",title:"Contract Callbacks in XCC",description:"In this post we focus on the need to refund tokens to a user in the event of an error. This will reveal a bit of a \u201cgotcha\u201d which developers new to the XCC may come across, and we\u2019ll discuss how to overcome it",date:"2023-11-17T00:00:00.000Z",tags:[{inline:!1,label:"Tutorials",permalink:"/blog/tags/tutorials",description:"Longer posts talking about the subject in detail"}],readingTime:4.513333333333334,hasTruncateMarker:!0,authors:[{name:"Michael Birch",title:"Senior Research Engineer",imageURL:"https://www.datocms-assets.com/95026/1683043123-t025c6kc9px-u025f7t5npl-c56792be0091-512.jpeg",key:"michael",page:null}],frontMatter:{title:"Contract Callbacks in XCC",description:"In this post we focus on the need to refund tokens to a user in the event of an error. This will reveal a bit of a \u201cgotcha\u201d which developers new to the XCC may come across, and we\u2019ll discuss how to overcome it",date:"2023-11-17",authors:["michael"],tags:["tutorials"],image:"https://www.datocms-assets.com/95026/1700215626-xcc-cc.png"},unlisted:!1,prevItem:{title:"Plugins for smart contract devs building on Near",permalink:"/blog/plugins-for-smart-contract-devs-building-on-near"},nextItem:{title:"Practical ERC20 Burning",permalink:"/blog/practical-erc20-burning"}},i={authorsImageUrls:[void 0]},l=[];function u(e){const t={a:"a",em:"em",p:"p",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["In previous posts, we have written about the cross-contract calls (XCC) feature on Aurora. These include ",(0,n.jsx)(t.a,{href:"/blog/cross-ecosystem-communication",children:(0,n.jsx)(t.em,{children:"an overview"})}),", ",(0,n.jsx)(t.a,{href:"/blog/building-a-game-using-near-aurora-and-bos",children:(0,n.jsx)(t.em,{children:"an application"})}),", and a ",(0,n.jsx)(t.a,{href:"/blog/communication-from-aurora-to-near-local-testing",children:(0,n.jsx)(t.em,{children:"deep dive into writing tests"})}),"."]}),"\n",(0,n.jsx)(t.p,{children:"In this post, we continue with the XCC technical deep dive by discussing in more detail handling XCC results using callbacks. In particular, we focus on the concrete example of needing to refund tokens to a user in the event of an error. Along the way, this example will reveal a bit of a \u201cgotcha\u201d which developers new to the XCC feature may come across, and we\u2019ll discuss how to overcome it."})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},7507:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>c});var n=o(9474);const a={},s=n.createContext(a);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);