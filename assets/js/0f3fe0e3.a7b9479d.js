"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[7853],{1403:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=t(3274),r=t(7507);const o={title:"Plugins for smart contract devs building on Near",description:"Let\u2019s discover how \u2018near-plugins\u2019 library could be used by your project, and how it can save you some time during the development of your smart contracts",date:"2024-01-19",authors:["moritz"],tags:["tutorials"],image:"https://www.datocms-assets.com/95026/1705627571-np2.png"},a=void 0,i={permalink:"/blog/plugins-for-smart-contract-devs-building-on-near",editUrl:"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/blog/plugins-for-smart-contract-devs-building-on-near.md",source:"@site/blog/plugins-for-smart-contract-devs-building-on-near.md",title:"Plugins for smart contract devs building on Near",description:"Let\u2019s discover how \u2018near-plugins\u2019 library could be used by your project, and how it can save you some time during the development of your smart contracts",date:"2024-01-19T00:00:00.000Z",tags:[{inline:!1,label:"Tutorials",permalink:"/blog/tags/tutorials",description:"Longer posts talking about the subject in detail"}],readingTime:4.733333333333333,hasTruncateMarker:!0,authors:[{name:"Moritz Zielke",title:"Research Engineer",imageURL:"https://www.datocms-assets.com/95026/1705626473-screenshot-2024-01-19-at-01-07-40.png",key:"moritz",page:null}],frontMatter:{title:"Plugins for smart contract devs building on Near",description:"Let\u2019s discover how \u2018near-plugins\u2019 library could be used by your project, and how it can save you some time during the development of your smart contracts",date:"2024-01-19",authors:["moritz"],tags:["tutorials"],image:"https://www.datocms-assets.com/95026/1705627571-np2.png"},unlisted:!1,prevItem:{title:"Managing Aurora's Validator staking with 'near-cli-rs'",permalink:"/blog/managing-aurora-s-validator-staking-with-near-cli-rs"},nextItem:{title:"Contract Callbacks in XCC",permalink:"/blog/contract-callbacks-in-xcc"}},c={authorsImageUrls:[void 0]},l=[{value:"Case study: A counter managing permissions with ACL",id:"case-study-a-counter-managing-permissions-with-acl",level:2},{value:"Permissions",id:"permissions",level:3},{value:"Managing permissions with ACL",id:"managing-permissions-with-acl",level:3},{value:"Step 1: Add <code>near-plugins</code> as a dependency",id:"step-1-add-near-plugins-as-a-dependency",level:3},{value:"Step 2: Define roles",id:"step-2-define-roles",level:3},{value:"Step 3: Make the contract <code>AccessControllable</code>",id:"step-3-make-the-contract-accesscontrollable",level:3},{value:"Step 4: Restrict contract methods",id:"step-4-restrict-contract-methods",level:3},{value:"Step 5: Grant permissions",id:"step-5-grant-permissions",level:3},{value:"Done",id:"done",level:2},{value:"Teaser: How it works internally",id:"teaser-how-it-works-internally",level:2},{value:"A note on testing",id:"a-note-on-testing",level:2},{value:"Ready for production, though?",id:"ready-for-production-though",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Some common functionality is required for many smart contracts. Examples are temporarily pausing certain features, staging and deploying a new version of the contract, and restricting access to contract methods. While such functionality is out of scope for an SDK like ",(0,s.jsx)(n.code,{children:"near-sdk-rs"}),", ideally it is not implemented anew for every smart contract."]}),"\n",(0,s.jsxs)(n.p,{children:["The most obvious benefits of an open-source library are reusability and the value it adds to the ecosystem. The smart contract features mentioned above can be tricky to implement and cumbersome to test. Without a library, developers might gloss over functionality that does not add business value but still is critical for security. As ",(0,s.jsx)(n.code,{children:"near-plugins"})," is open-source and used by many developers, there are more engineering hours and eyeballs dedicated to it compared to a solution specific to a single smart contract."]}),"\n",(0,s.jsx)(n.h2,{id:"case-study-a-counter-managing-permissions-with-acl",children:"Case study: A counter managing permissions with ACL"}),"\n",(0,s.jsxs)(n.p,{children:["Let\u2019s look at a case study to see how ",(0,s.jsx)(n.code,{children:"near-plugins"})," can be useful to smart contract developers. We are building a ",(0,s.jsx)(n.code,{children:"Counter"})," that stores its current value and has methods to increment, decrement, and reset the value. It is intentionally kept simple to allow us to focus on how ",(0,s.jsx)(n.code,{children:"near-plugins"})," adds functionality. This is what the contract looks like prior to using any plugins:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[near_bindgen]\nimpl Counter {\n    #[init]\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    /// Anyone can retrieve the current value.\n    pub fn value(&self) -> i64 {\n        self.value\n    }\n\n    /// Increases the value of the counter by one.\n    pub fn increment(&mut self) {\n        self.value += 1;\n    }\n\n    /// Decreases the value of the counter by one.\n    pub fn decrement(&mut self) {\n        self.value -= 1;\n    }\n\n    /// Resets the value of the counter to zero.\n    pub fn reset(&mut self) {\n        self.value = 0;\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The final version of the code is available ",(0,s.jsx)(n.a,{href:"https://github.com/mooori/counter-acl-example",children:(0,s.jsx)(n.em,{children:"in this repository on github"})}),". The ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.code,{children:"Counter"})})," example is inspired by ",(0,s.jsx)(n.a,{href:"https://github.com/near-examples/counter-rust",children:(0,s.jsx)(n.em,{children:"near-examples/counter-rust"})}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"permissions",children:"Permissions"}),"\n",(0,s.jsxs)(n.p,{children:["The contract methods defined above can be called by anyone since they are public and inside an implementation block marked with ",(0,s.jsx)(n.code,{children:"#[near_bindgen]"}),". Using ",(0,s.jsx)(n.code,{children:"near-sdk-rs"})," it is possible to restrict some methods such that they can be called only by the contract itself. Either by using ",(0,s.jsx)(n.code,{children:"#[private]"})," or by not exposing the method publicly, as described in the ",(0,s.jsx)(n.a,{href:"https://docs.near.org/sdk/rust/contract-interface/private-methods",children:"documentation"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["However, what if we wanted to implement more flexible permissions (e.g. allowing only some set of accounts to call a given function)? This is where the ",(0,s.jsx)(n.a,{href:"https://github.com/aurora-is-near/near-plugins#accesscontrollable",children:(0,s.jsx)(n.code,{children:"AccessControllable"})})," plugin comes in handy."]}),"\n",(0,s.jsx)(n.h3,{id:"managing-permissions-with-acl",children:"Managing permissions with ACL"}),"\n",(0,s.jsxs)(n.p,{children:["ACL stands for ",(0,s.jsx)(n.em,{children:"access control lists"})," and they are used in the following way within the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," plugin. The user defines the roles required for their use case as Rust enum variants. Then it is possible to restrict access to a method to accounts that have been granted roles. Restricting access is possible with one line of code, for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[access_control_any(roles(Role::Decrementer))]\npub fn decrement(&mut self) {\n    // ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let\u2019s walk through it step by step to see how you can make your Near smart contract ",(0,s.jsx)(n.code,{children:"AccessControllable"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"step-1-add-near-plugins-as-a-dependency",children:["Step 1: Add ",(0,s.jsx)(n.code,{children:"near-plugins"})," as a dependency"]}),"\n",(0,s.jsxs)(n.p,{children:["For now, ",(0,s.jsx)(n.code,{children:"near-plugins"})," has not yet been published on crates.io. Still, the crate is ready for usage and it can be added as git dependency:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'# Add `near-plugins` under `dependencies` in your Cargo.toml.\n\n[dependencies]\nnear-plugins = { git = "https://github.com/aurora-is-near/near-plugins.git", tag = "v0.2.0" }\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-define-roles",children:"Step 2: Define roles"}),"\n",(0,s.jsxs)(n.p,{children:["Every use case may require a different set of roles, so users may define their roles as variants of an enum. For the ",(0,s.jsx)(n.code,{children:"Counter"})," example, we define the following roles:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(AccessControlRole, Deserialize, Serialize, Copy, Clone)]\n#[serde(crate = "near_sdk::serde")]\npub enum Role {\n    /// Grantees of this role may decrease the counter.\n    Decrementer,\n    /// Grantees of this role may reset the counter.\n    Resetter,\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Deriving the ",(0,s.jsx)(n.code,{children:"AccessControlRole"})," trait prepares the ",(0,s.jsx)(n.code,{children:"Role"})," enum for usage in the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," plugin."]}),"\n",(0,s.jsxs)(n.h3,{id:"step-3-make-the-contract-accesscontrollable",children:["Step 3: Make the contract ",(0,s.jsx)(n.code,{children:"AccessControllable"})]}),"\n",(0,s.jsxs)(n.p,{children:["The contract is made ",(0,s.jsx)(n.code,{children:"AccessControllable"})," by attaching the ",(0,s.jsx)(n.code,{children:"access_control"})," attribute macro on the definition of the struct which represents the contract\u2019s state. We pass our ",(0,s.jsx)(n.code,{children:"Role"})," as argument to make the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," implementation aware of it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[access_control(role_type(Role))]\n#[near_bindgen]\n#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]\npub struct Counter {\n    value: i64,\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-restrict-contract-methods",children:"Step 4: Restrict contract methods"}),"\n",(0,s.jsxs)(n.p,{children:["Access to a contract method is restricted by attaching ",(0,s.jsx)(n.code,{children:"#[access_control_any]"})," and providing the roles to be whitelisted as arguments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[near_bindgen]\nimpl Counter {\n    // We must be inside an implementation block with `#[near-bindgen]`.\n\n    /// Resets the value of the counter to zero.\n    ///\n    /// Only accounts that have been granted `Role::Resetter` may successfully call this method.\n    /// If called by an account without this role, the method panics and state remains unchanged.\n    #[access_control_any(roles(Role::Resetter))] // enables ACL for this method\n    pub fn reset(&mut self) {\n        self.value = 0;\n    }\n\n    /// By the way, it is also possible to restrict access to accounts that have been granted any of\n    /// multiple roles. This is how the syntax looks.\n    #[access_control_any(roles(Role::Decrementer, Role::Resetter))]\n    pub fn no_op(&self) { }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now the contract is set up for access control. The only step that is missing is granting roles to accounts, enabling them to call restricted methods."}),"\n",(0,s.jsx)(n.h3,{id:"step-5-grant-permissions",children:"Step 5: Grant permissions"}),"\n",(0,s.jsxs)(n.p,{children:["In our contract\u2019s constructor method ",(0,s.jsx)(n.code,{children:"new()"})," we make the contract itself super admin:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'near_sdk::require!(\n    contract.acl_init_super_admin(env::current_account_id()),\n    "Failed to initialize super admin",\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AccessControllable"})," super admin is an admin for every role defined in the ",(0,s.jsx)(n.code,{children:"Role"})," enum. For this example, it is sufficient to know that a super admin may grant and revoke every role. Making the contract itself super admin facilitates the setup procedure as well as testing. More detailed information on admin roles can be found in the ",(0,s.jsx)(n.a,{href:"https://github.com/aurora-is-near/near-plugins/blob/master/near-plugins/src/access_controllable.rs",children:"documentation"})," of the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," trait."]}),"\n",(0,s.jsxs)(n.p,{children:["To grant the ",(0,s.jsx)(n.code,{children:"Resetter"})," role to the account ",(0,s.jsx)(n.code,{children:"alice.near"}),", the contract can call the following function on itself:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'/// See `AccessControllable::acl_grant_role` for details.\nacl_grant_role("Resetter", "alice.near");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AccessControllable"})," trait provides many more methods to administer ACL permissions. After following the steps above, all of them are automatically implemented for a contract using the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," plugin."]}),"\n",(0,s.jsx)(n.h2,{id:"done",children:"Done"}),"\n",(0,s.jsxs)(n.p,{children:["The steps above are sufficient to add complex and configurable ACL permissions to a contract using ",(0,s.jsx)(n.code,{children:"near-plugins"}),". At this point, ",(0,s.jsx)(n.code,{children:"alice.near"})," is the only account which has been granted the ",(0,s.jsx)(n.code,{children:"Resetter"})," role. This means that only ",(0,s.jsx)(n.code,{children:"alice.near"})," may successfully call the contract\u2019s ",(0,s.jsx)(n.code,{children:"reset()"})," method."]}),"\n",(0,s.jsxs)(n.p,{children:["The repo contains an ",(0,s.jsx)(n.a,{href:"https://github.com/mooori/counter-acl-example/blob/main/tests/workflow.rs",children:"integration test"})," which verifies that ",(0,s.jsx)(n.code,{children:"AccessControllable"})," was set up correctly for our ",(0,s.jsx)(n.code,{children:"Counter"})," contract. Take a look at it to learn more about interacting with an ",(0,s.jsx)(n.code,{children:"AccessControllable"})," contract. To run the test on-chain in a local sandbox, it suffices to clone the repo and execute the following command. This is made possible by ",(0,s.jsx)(n.a,{href:"https://github.com/near/near-workspaces-rs",children:"near-workspaces-rs"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-undefined",children:"cargo test\n"})}),"\n",(0,s.jsx)(n.h2,{id:"teaser-how-it-works-internally",children:"Teaser: How it works internally"}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"AccessControllable"})," extends the contract state to store the permissions that have been granted. Moreover, the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," trait is implemented for the contract to enable administering permissions. When ",(0,s.jsx)(n.code,{children:"#[access_control_any(roles(...))]"})," is attached to a method, ",(0,s.jsx)(n.code,{children:"near-plugin"})," injects code that checks if the caller was granted any of the required roles. If not, a panic is generated which aborts the function call."]}),"\n",(0,s.jsxs)(n.p,{children:["To learn about all the details, you can dive into the ",(0,s.jsx)(n.a,{href:"https://github.com/aurora-is-near/near-plugins/blob/master/near-plugins-derive/src/access_controllable.rs",children:"implementation"})," of the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," macro."]}),"\n",(0,s.jsx)(n.h2,{id:"a-note-on-testing",children:"A note on testing"}),"\n",(0,s.jsxs)(n.p,{children:["The functionality provided by ",(0,s.jsx)(n.code,{children:"near-plugins"})," is critical for security and we strive to test it exhaustively. In tests, we compile demo contracts for all plugins and deploy them on-chain in a local sandbox. Then we verify that using a particular plugin adds exactly the expected functionality to the contract. These tests and demo contracts can be found ",(0,s.jsx)(n.a,{href:"https://github.com/aurora-is-near/near-plugins/tree/master/near-plugins-derive/tests",children:"here"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"ready-for-production-though",children:"Ready for production, though?"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned earlier, ",(0,s.jsx)(n.code,{children:"near-plugins"})," comes with the caveat of not yet being published to ",(0,s.jsx)(n.em,{children:"crates.io"}),". Nevertheless, it is already used in some contracts on mainnet, e.g. contracts related to the ",(0,s.jsx)(n.a,{href:"https://rainbowbridge.app/transfer",children:"Rainbow Bridge"}),". Moreover, both ",(0,s.jsx)(n.a,{href:"https://www.datocms-assets.com/50156/1680101850-hacken-near-plugins-final-report-updated-march2023.pdf",children:"Hacken"})," and ",(0,s.jsx)(n.a,{href:"https://www.datocms-assets.com/50156/1680590522-auditone-near-plugins-final-report-updated-march2023.pdf",children:"AuditOne"})," audited ",(0,s.jsx)(n.code,{children:"near-plugins"}),", awarding it high scores."]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"near-plugins"}),", developers can add complex functionality to their smart contracts with just a few lines of code. Developers can focus on creating value for their users by relying on ",(0,s.jsx)(n.code,{children:"near-plugins"})," for some cumbersome administrative tasks that are nevertheless critical for security. We are testing all plugins extensively and the ",(0,s.jsx)(n.code,{children:"near-plugins"})," crate has been audited twice. We hope to contribute to the Near ecosystem by providing secure smart contract plugins which developers can build upon."]}),"\n",(0,s.jsxs)(n.p,{children:["This article provides a step-by-step guide to using the ",(0,s.jsx)(n.code,{children:"AccessControllable"})," plugin. In principle, using other plugins is similar. Head over to the ",(0,s.jsx)(n.a,{href:"https://github.com/aurora-is-near/near-plugins",children:"repository"})," and have a look at the documentation and tests to get started with other plugins."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7507:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(9474);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);