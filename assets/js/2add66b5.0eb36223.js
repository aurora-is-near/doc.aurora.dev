"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[8123],{8657:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var r=t(694),a=t(3274),o=t(7507);const s={title:"Integration tests for XCC communication",description:"XCC is a powerful tool to merge blockchain ecosystems together. In this post we will talk about how to write integration tests for the XCC contracts communicating between Aurora and Near using Rust",date:"2023-09-08",authors:["olga"],tags:["tutorials"],image:"https://www.datocms-assets.com/95026/1694085970-article-cover.png"},c=void 0,i={authorsImageUrls:[void 0]},l=[{value:"Counter contract on Near",id:"counter-contract-on-near",level:2},{value:"Counter contract on Aurora",id:"counter-contract-on-aurora",level:2},{value:"Install dependencies for counter contract on Aurora",id:"install-dependencies-for-counter-contract-on-aurora",level:3},{value:"Integration test",id:"integration-test",level:2},{value:"Deploy Near contract in integration tests",id:"deploy-near-contract-in-integration-tests",level:3},{value:"Deploy Aurora Engine and wNEAR",id:"deploy-aurora-engine-and-wnear",level:3},{value:"Deploy counter contract on Aurora in integration tests",id:"deploy-counter-contract-on-aurora-in-integration-tests",level:3},{value:"Mint wNEAR for user",id:"mint-wnear-for-user",level:3},{value:"Call incrementXCC method in counter contract on Aurora",id:"call-incrementxcc-method-in-counter-contract-on-aurora",level:3},{value:"Check counter value on Near",id:"check-counter-value-on-near",level:3},{value:"Run final test",id:"run-final-test",level:3},{value:"Git Action",id:"git-action",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In this article, we will learn how to write local tests for the Aurora contracts, which use ",(0,a.jsx)(n.a,{href:"/blog/cross-ecosystem-communication",children:"XCC calls"})," to Near ecosystem. I will use a simple example to demonstrate it, step by step, we will write:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"A simple counter contract for Near blockchain."}),"\n",(0,a.jsx)(n.li,{children:"Contract on Aurora, which calls the contract on Near by using the XCC."}),"\n",(0,a.jsxs)(n.li,{children:["One integration test in the ",(0,a.jsx)(n.code,{children:"sandbox"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Setup the ",(0,a.jsx)(n.code,{children:"git action"})," for running this test automatically."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The example described in this article: ",(0,a.jsx)(n.a,{href:"https://github.com/olga24912/AuroraToNearXCCExample",children:"https://github.com/olga24912/AuroraToNearXCCExample"})]}),"\n",(0,a.jsx)(n.h2,{id:"counter-contract-on-near",children:"Counter contract on Near"}),"\n",(0,a.jsx)(n.p,{children:"I assume that you have already cloned a git repo locally or just created your own repo, in the case you want to add everything file by file to your project using this article."}),"\n",(0,a.jsxs)(n.p,{children:["We will start with creating a simple Counter contract on Near, which just has two functions: ",(0,a.jsx)(n.code,{children:"increment"})," \u2013 for changing the value, and ",(0,a.jsx)(n.code,{children:"get_num"})," \u2013 to return the current value."]}),"\n",(0,a.jsxs)(n.p,{children:["We should have the following directories and files in ",(0,a.jsx)(n.code,{children:"near"})," folder:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:"AuroraToNearXCCExample: \n|-- near\n|   |-- contracts\n|   |   |-- build.sh\n|   |   |-- Cargo.toml\n|   |   |-- src\n|   |   |   |-- lib.rs\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let's take a look at each of the files."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"lib.rs"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{near_bindgen, PanicOnDefault};\n\n#[near_bindgen]\n#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]\npub struct Counter {\n    val: u64,\n}\n\n#[near_bindgen]\nimpl Counter {\n    #[init]\n    pub fn new() -> Self {\n        Self{\n            val: 0\n        }\n    }\n\n    pub fn get_num(&self) -> u64 {\n        return self.val;\n    }\n\n    pub fn increment(&mut self, value: u64) {\n        self.val += value;\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "counter"\nversion = "0.1.0"\nedition = "2021"\n\n[lib]\ncrate-type = ["cdylib", "rlib"]\n\n[dependencies]\nnear-sdk = "4.1.1"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For compiling the contract into a WASM file, we will use the script ",(0,a.jsx)(n.code,{children:"build.sh"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"#!/bin/sh\nset -e\n\nrustup target add wasm32-unknown-unknown\nRUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release\n"})}),"\n",(0,a.jsx)(n.p,{children:"To compile the contract run:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"./build.sh\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The target file: ",(0,a.jsx)(n.code,{children:"near/contracts/target/wasm32-unknown-unknown/release/counter.wasm"})]}),"\n",(0,a.jsx)(n.h2,{id:"counter-contract-on-aurora",children:"Counter contract on Aurora"}),"\n",(0,a.jsxs)(n.p,{children:["We already created a counter contract for Near, and now let's create the counter contract on Aurora, which will have one method ",(0,a.jsx)(n.code,{children:"incrementXCC"})," inside, which we will call the ",(0,a.jsx)(n.code,{children:"increment"})," method in the Near Counter contract."]}),"\n",(0,a.jsxs)(n.p,{children:["First, create the following folder structure and the ",(0,a.jsx)(n.code,{children:"Counter.sol"})," file"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"AuroraToNearXCCExample:\n|-- aurora\n|   |-- contracts\n|   |   |-- src\n|   |   |   |-- Counter.sol\n|-- near\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Counter.sol"})," file:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.0;\n\nimport {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport {AuroraSdk, NEAR, PromiseCreateArgs} from "@auroraisnear/aurora-sdk/aurora-sdk/AuroraSdk.sol";\n\ncontract Counter {\n    using AuroraSdk for NEAR;\n    using AuroraSdk for PromiseCreateArgs;    \n\n    uint64 constant COUNTER_NEAR_GAS = 10_000_000_000_000;\n    \n    NEAR public near;\n    string counterAccountId;\n\n    constructor(address wnearAddress, string memory counterNearAccountId) {\n        near = AuroraSdk.initNear(IERC20(wnearAddress));\n        counterAccountId = counterNearAccountId;\n    }\n\n    function incrementXCC() external {\n        bytes memory args = bytes(\'{"value": 1}\');\n        PromiseCreateArgs memory callCounter = near.call(\n            counterAccountId,\n            "increment",\n            args,\n            0,\n            COUNTER_NEAR_GAS\n        );\n        callCounter.transact();\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["More information about how the aurora contracts with XCC work can be found ",(0,a.jsx)(n.a,{href:"/blog/cross-ecosystem-communication",children:"here,"})," or ",(0,a.jsx)(n.a,{href:"/blog/building-a-game-using-near-aurora-and-bos",children:"in this game example,"})," or in these ",(0,a.jsx)(n.a,{href:"https://github.com/aurora-is-near/aurora-contracts-sdk/blob/main/docs/NearFromAurora.md",children:"official docs"})," in aurora-contracts-sdk repo."]}),"\n",(0,a.jsx)(n.h3,{id:"install-dependencies-for-counter-contract-on-aurora",children:"Install dependencies for counter contract on Aurora"}),"\n",(0,a.jsxs)(n.p,{children:["For deploying the counter contract on Aurora in integration tests, we should install ",(0,a.jsx)(n.code,{children:"foundry"})," and the dependencies. First, go to ",(0,a.jsx)(n.code,{children:"aurora"})," folder and install ",(0,a.jsx)(n.code,{children:"aurora-sdk"})," by running:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"yarn init\nyarn add @auroraisnear/aurora-sdk\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For compiling aurora contracts in the test, we will use foundry. How to install foundry you can read ",(0,a.jsx)(n.a,{href:"https://book.getfoundry.sh/getting-started/installation",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["We should create ",(0,a.jsx)(n.code,{children:"foundry.toml"})," in ",(0,a.jsx)(n.code,{children:"aurora/contracts"})," folder."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"AuroraToNearXCCExample:\n|-- aurora\n|   |-- contracts\n|   |   |-- src\n|   |   |-- foundry.toml\n|   |-- integration-tests\n|-- near\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"foundry.toml"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:"[profile.default]\nsrc = 'src'\nout = 'out'\nlibs = ['lib', '../node_modules']\nallow_paths = []\nsolc = \"0.8.17\"\n"})}),"\n",(0,a.jsxs)(n.p,{children:["After that you need to run the next command from ",(0,a.jsx)(n.code,{children:"aurora/contracts"})," folder:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"rm -rf lib/aurora-contracts-sdk\nforge install aurora-is-near/aurora-contracts-sdk --no-commit\n"})}),"\n",(0,a.jsxs)(n.p,{children:["After command execution in the ",(0,a.jsx)(n.code,{children:"aurora/contracts"})," directory, the ",(0,a.jsx)(n.code,{children:"lib"})," folder with ",(0,a.jsx)(n.code,{children:"aurora-contracts-sdk"})," and all necessary files inside will be created."]}),"\n",(0,a.jsx)(n.h2,{id:"integration-test",children:"Integration test"}),"\n",(0,a.jsxs)(n.p,{children:["It is time to create an integration test! Go back to the ",(0,a.jsx)(n.code,{children:"aurora"})," folder with ",(0,a.jsx)(n.code,{children:"cd .."})," and run (or just use already existing folder from repo):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"cargo new --lib integration-tests\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"integration-tests"})," folder will be created. We should also create the following ",(0,a.jsx)(n.code,{children:"rust-toolchain"})," file in this folder:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'[toolchain]\nchannel = "1.66.1"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We need this because this channel is used in dependencies, and we should use the same channel to make contracts work properly. For people outside the Rust community, you can think about this as setting the Rust version, more info is ",(0,a.jsx)(n.a,{href:"https://rust-lang.github.io/rustup/concepts/toolchains.html",children:"here"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"We should obtain this folder structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"AuroraToNearXCCExample:\n|-- aurora\n|   |-- contracts\n|   |-- integration-tests\n|   |   |-- Cargo.toml\n|   |   |-- src\n|   |   |   |-- lib.rs\n|   |   |-- rust-toolchain\n|-- near\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Edit now ",(0,a.jsx)(n.code,{children:"lib.rs"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[cfg(test)]\nmod tests {\n    use aurora_sdk_integration_tests::tokio;\n    \n    #[tokio::test]\n    async fn counter_test() {\n    \n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"and Cargo.toml"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "integration-tests"\nversion = "0.1.0"\nedition = "2021"\n\n[dependencies]\naurora-sdk-integration-tests = { git = "https://github.com/aurora-is-near/aurora-contracts-sdk.git" }\nnear-sdk = "4.1.1"\n'})}),"\n",(0,a.jsx)(n.p,{children:"The command for running the test should run this succesfully:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cargo test\n"})}),"\n",(0,a.jsx)(n.p,{children:"You should see output like this afterwards:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"Compiling integration-tests v0.1.0 (/Users/aurora/Projects/AuroraToNearXCCExample/aurora/integration-tests)\n    Finished test [unoptimized + debuginfo] target(s) in 2.86s\n     Running unittests src/lib.rs (target/debug/deps/integration_tests-307b69604bee401f)\n\nrunning 1 test\ntest tests::counter_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00ss\n"})}),"\n",(0,a.jsx)(n.h3,{id:"deploy-near-contract-in-integration-tests",children:"Deploy Near contract in integration tests"}),"\n",(0,a.jsxs)(n.p,{children:["Let's start writing our test with compiling and deploying the Counter contract on Near inside the sandbox. To do this we will: create the sandbox workspace with ",(0,a.jsx)(n.code,{children:"workspaces::sandbox()"}),", compile near contract by using ",(0,a.jsx)(n.code,{children:"build.sh"})," script (as we did above in section ",(0,a.jsx)(n.code,{children:"Create Counter contract on Near"}),"), deploy the contract with ",(0,a.jsx)(n.code,{children:"worker.dev_deploy"})," and call the constructor with ",(0,a.jsx)(n.code,{children:'near_counter.call("new").'})]}),"\n",(0,a.jsxs)(n.p,{children:["All of that is inside the ",(0,a.jsx)(n.code,{children:"deploy_near_counter"})," function, which we will use now directly in our ",(0,a.jsx)(n.code,{children:"counter_test"}),". The full code is below:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'#[cfg(test)]\nmod tests {\n    use aurora_sdk_integration_tests::{tokio, workspaces, {utils::process}};\n    use aurora_sdk_integration_tests::workspaces::Contract;\n    use std::path::Path;\n\n    #[tokio::test]\n    async fn counter_test() {\n        let worker = workspaces::sandbox().await.unwrap();\n        let near_counter = deploy_near_counter(&worker).await;\n    }\n\n    async fn deploy_near_counter(\n        worker: &workspaces::Worker[workspaces::network::Sandbox](workspaces::network::Sandbox),\n    ) -> Contract {\n        let contract_path = Path::new("../../near/contracts");\n        let output = tokio::process::Command::new("bash")\n            .current_dir(contract_path)\n            .args(["build.sh"])\n            .output()\n            .await\n            .unwrap();\n\n        process::require_success(&output).unwrap();\n\n        let artifact_path =\n            contract_path.join("target/wasm32-unknown-unknown/release/counter.wasm");\n        let wasm_bytes = tokio::fs::read(artifact_path).await.unwrap();\n        let near_counter = worker.dev_deploy(&wasm_bytes).await.unwrap();\n\n        near_counter.call("new").transact().await.unwrap().into_result().unwrap();\n\n        near_counter\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can run ",(0,a.jsx)(n.code,{children:"cargo test"})," to check if your code is working at this stage."]}),"\n",(0,a.jsx)(n.h3,{id:"deploy-aurora-engine-and-wnear",children:"Deploy Aurora Engine and wNEAR"}),"\n",(0,a.jsx)(n.p,{children:"Now, let's deploy the Aurora Engine contract itself to the sandbox. Also, we will need to deploy wNEAR in Aurora. It is the ERC-20 on Aurora which corresponds to the Near token on Near. We will use this token later for the payment."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"#[cfg(test)]\nmod tests {\n    use aurora_sdk_integration_tests::{tokio, workspaces, {utils::process}, aurora_engine, wnear, workspaces::Contract};\n    use aurora_sdk_integration_tests::workspaces::Contract;\n    use std::path::Path;\n\n    #[tokio::test]\n    async fn counter_test() {\n        let worker = workspaces::sandbox().await.unwrap();\n        let near_counter = deploy_near_counter(&worker).await;\n\n        let engine = aurora_engine::deploy_latest(&worker).await.unwrap();\n        let wnear = wnear::Wnear::deploy(&worker, &engine).await.unwrap();\n    }\n    ...\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"deploy-counter-contract-on-aurora-in-integration-tests",children:"Deploy counter contract on Aurora in integration tests"}),"\n",(0,a.jsx)(n.p,{children:"Moving to deploying counter contract to Aurora. We are creating a new user account and function to deploy the counter. This function takes: (1) aurora engine, (2) user account, (3) wNear address on aurora, (4) Counter Account ID on Near."}),"\n",(0,a.jsx)(n.p,{children:"Let's add new dependencies first:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[cfg(test)]\nmod tests {\n    use aurora_sdk_integration_tests::{tokio, workspaces, {utils::process}, aurora_engine, wnear, ethabi};\n    use aurora_sdk_integration_tests::workspaces::Contract;\n    use std::path::Path;\n    \n    use aurora_sdk_integration_tests::aurora_engine_types::types::{Address};\n    use aurora_sdk_integration_tests::aurora_engine::AuroraEngine;\n    use aurora_sdk_integration_tests::utils::forge;\n    use aurora_sdk_integration_tests::utils::ethabi::DeployedContract;\n...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now let's define ",(0,a.jsx)(n.code,{children:"deploy_aurora_counter"})," function and add it to out test:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"//....\n    #[tokio::test]\n    async fn counter_test() {\n        //....\n        \n        let user_account = worker.dev_create_account().await.unwrap();\n        let aurora_counter = deploy_aurora_counter(&engine, &user_account, wnear.aurora_token.address, &near_counter).await;\n    }\n\n    async fn deploy_aurora_counter(engine: &AuroraEngine,\n                                   user_account: &workspaces::Account,\n                                   wnear_address: Address,\n                                   near_counter: &Contract) -> DeployedContract {\n        //....\n    }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To deploy aurora contract we should first compile and deploy ",(0,a.jsx)(n.code,{children:"aurora_sdk_lib"}),", and corresponding dependencies:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'async fn deploy_aurora_counter(engine: &AuroraEngine,\n                                   user_account: &workspaces::Account,\n                                   wnear_address: Address,\n                                   near_counter: &Contract) -> DeployedContract {\n    let contract_path = "../contracts";\n\n    let aurora_sdk_path = Path::new("../contracts/lib/aurora-contracts-sdk/aurora-solidity-sdk");\n    let codec_lib = forge::deploy_codec_lib(&aurora_sdk_path, engine).await.unwrap();\n    let utils_lib = forge::deploy_utils_lib(&aurora_sdk_path, engine).await.unwrap();\n    let aurora_sdk_lib = forge::deploy_aurora_sdk_lib(&aurora_sdk_path, engine, codec_lib, utils_lib).await.unwrap();\n\n    //....\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"After that, we can compile and deploy the counter contract itself:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'    //....\n    \n    let constructor = forge::forge_build(\n                      contract_path,\n                      &[format!(\n                         "@auroraisnear/aurora-sdk/aurora-sdk/AuroraSdk.sol:AuroraSdk:0x{}",\n                         aurora_sdk_lib.encode()\n                       )], \n                       &["out", "Counter.sol", "Counter.json"]).await.unwrap();\n\n    let deploy_bytes = constructor.create_deploy_bytes_with_args(&[\n            ethabi::Token::Address(wnear_address.raw()),\n            ethabi::Token::String(near_counter.id().to_string()),\n        ]);\n\n    let address = engine\n            .deploy_evm_contract_with(user_account, deploy_bytes)\n            .await\n            .unwrap();\n\n    constructor.deployed_at(address)\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"mint-wnear-for-user",children:"Mint wNEAR for user"}),"\n",(0,a.jsxs)(n.p,{children:["When we use XCC for the first time in our setup, the implicit contract on the Near will be created. You can read more about it ",(0,a.jsx)(n.a,{href:"https://github.com/aurora-is-near/aurora-contracts-sdk/blob/main/docs/NearFromAurora.md",children:"here"}),". We also could call this implicit contract as sub-account. The overall scheme could be presented as:"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://www.datocms-assets.com/95026/1694083461-screenshot-2023-09-07-at-11-42-21.png",alt:""})}),"\n",(0,a.jsx)(n.p,{children:"Creation of a sub-account will cost you 2 NEAR tokens. That is why we need to mint 2 wNEAR for our user on Aurora after approving the spending of the wNear by counter contract."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"///....\nuse aurora_sdk_integration_tests::aurora_engine_sdk::types::near_account_to_evm_address;\nuse aurora_sdk_integration_tests::aurora_engine_types::{U256, types::Wei};\n\n#[tokio::test]\nasync fn counter_test() {\n    //....\n\n    let user_address = near_account_to_evm_address(user_account.id().as_bytes());\n    const NEAR_DEPOSIT: u128 = 2 * near_sdk::ONE_NEAR;\n\n    engine.mint_wnear(&wnear, user_address, NEAR_DEPOSIT).await.unwrap();\n\n    let evm_call_args = wnear\n        .aurora_token\n        .create_approve_call_bytes(aurora_counter.address, U256::MAX);\n    \n    let result = engine\n        .call_evm_contract_with(\n        &user_account,\n        wnear.aurora_token.address,\n        evm_call_args,\n        Wei::zero()).await.unwrap();\n    aurora_engine::unwrap_success(result.status).unwrap();\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"call-incrementxcc-method-in-counter-contract-on-aurora",children:"Call incrementXCC method in counter contract on Aurora"}),"\n",(0,a.jsxs)(n.p,{children:["In this section, we will write a function that calls the ",(0,a.jsx)(n.code,{children:"incrementXCC"})," method in the Counter contract on Aurora. ",(0,a.jsx)(n.code,{children:"incrementXCC"})," method is calling inside the ",(0,a.jsx)(n.code,{children:"increment"})," method from the Near contract and counter is incremented on Near."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's write ",(0,a.jsx)(n.code,{children:"increment"})," function in our test now, which will call the ",(0,a.jsx)(n.code,{children:"incrementXCC"})," from the Aurora's contract. We'll provide as input: (1) aurora engine contract deployed in the sandbox, (2) the near account of the user which will sign the transaction, (3) the counter contract deployed on aurora."]}),"\n",(0,a.jsxs)(n.p,{children:["Notice that we're going to call the method in the aurora contract, but in this function, the user account ID on Near is provided. We can do this because it is possible to call the aurora's counter contract method by using ",(0,a.jsx)(n.code,{children:"call"})," method from the Aurora Engine contract."]}),"\n",(0,a.jsxs)(n.p,{children:["In that case, the near user will sign a transaction, but inside the Aurora Engine, there is ",(0,a.jsx)(n.a,{href:"https://github.com/aurora-is-near/aurora-engine/blob/71980db92a9d4b95d4e1f53954b98e0e8f002a4b/engine-sdk/src/types.rs#L28",children:"an implicit mapping"})," between the near account ID and aurora addresses. And it is precisely how we will communicate with the contract in our test."]}),"\n",(0,a.jsxs)(n.p,{children:["Now, let's first encode the arguments for the ",(0,a.jsx)(n.code,{children:"call"})," method in the ",(0,a.jsx)(n.code,{children:"AuroraEngine"})," contract on Near and after that \u2013 submit a transaction and check its result:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'//....\nuse aurora_sdk_integration_tests::aurora_engine_types::parameters::engine::{CallArgs, FunctionCallArgsV1};\n\n#[tokio::test]\nasync fn counter_test() {\n    //....\n\n    increment(&engine, &user_account, aurora_counter).await;\n}\n\nasync fn increment(\n    engine: &AuroraEngine,\n    user_account: &workspaces::Account,\n    aurora_counter: DeployedContract\n) {\n  \n  let contract_args = aurora_counter.create_call_method_bytes_without_args("incrementXCC");\n\n  let result = engine\n      .call_evm_contract_with(\n          &user_account,\n          aurora_counter.address,\n          ContractInput(contract_args),\n          Wei::zero(),\n      )\n      .await\n      .unwrap();\n  \n  aurora_engine::unwrap_success(result.status).unwrap();\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"check-counter-value-on-near",children:"Check counter value on Near"}),"\n",(0,a.jsxs)(n.p,{children:["Let\u2019s check that the counter has been incremented at the Counter contract on Near. For that, call the ",(0,a.jsx)(n.code,{children:"get_num"})," view method at the counter and check that the result equals 1."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[tokio::test]\nasync fn counter_test() {\n    //....\n    \n    let counter_val: u64 = near_counter.view("get_num").await.unwrap().json().unwrap();\n    assert_eq!(counter_val, 1);\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"run-final-test",children:"Run final test"}),"\n",(0,a.jsxs)(n.p,{children:["Now, when everything is ready, let's go to ",(0,a.jsx)(n.code,{children:"aurora/integration-tests/"})," directory and run to check that we have the expected results:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cargo test\n"})}),"\n",(0,a.jsx)(n.h2,{id:"git-action",children:"Git Action"}),"\n",(0,a.jsxs)(n.p,{children:["Now, let's set up the git action so that the test runs automatically every time we push changes. To set it up, we must create ",(0,a.jsx)(n.code,{children:".github/workflow/test.yml"})," and ",(0,a.jsx)(n.code,{children:"Makefile"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"AuroraToNearXCCExample:\n|-- aurora\n|-- near\n|-- Makefile\n|-- .github/workflow/test.yml\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:".github/workflows/test.yml"})," contains the git action description. In our case, we are going to run it on ",(0,a.jsx)(n.code,{children:"push"})," events. First, we install ",(0,a.jsx)(n.code,{children:"foundry"})," for compiling our Solidity contracts, second, we checkout the repository with all submodules, and in the end, run the script from Makefile."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"name: aurora-to-near-xcc-example test automatically\n\non: [push]\n\njobs:\n  test-counter:\n    runs-on: ubuntu-latest\n    name: Test counter\n    steps:\n      - name: Install Foundry\n        uses: foundry-rs/foundry-toolchain@v1\n      - name: Clone the repository\n        uses: actions/checkout@v3\n        with: \n          submodules: recursive\n      - name: Test\n        run: |\n          make test-counter\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, let\u2019s take a closer look at the ",(0,a.jsx)(n.code,{children:"Makefile"})," . First, we go to the ",(0,a.jsx)(n.code,{children:"aurora"})," directory and install dependencies, second, we compile near contracts, and in the end, run our integration test."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-makefile",children:"test-counter:\n        cd aurora && \\\\\n        yarn add @auroraisnear/aurora-sdk && \\\\\n        cd ../near/contracts && \\\\\n        ./build.sh && \\\\\n        cd ../../aurora/integration-tests && \\\\\n        cargo test --all --jobs 4 -- --test-threads 4\n"})}),"\n",(0,a.jsx)(n.p,{children:"That is it, we have set up the git action! Now, our integration test will run automatically after each push to our GitHub repo."}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"In this article, we have created a simple contract on Aurora, which calls the function from Near contract. We have learned how it is possible to test such contracts inside the sandbox locally. And in the end, we have set up the git action to make the test run automatically."}),"\n",(0,a.jsx)(n.p,{children:"I hope this article will make it easier for you to develop contracts on Aurora with XCC to Near."}),"\n",(0,a.jsxs)(n.p,{children:["Happy development! In a case you will have any questions about this article, feel free to contract our DevSupport team on ",(0,a.jsx)(n.a,{href:"https://discord.com/invite/dEFJBz8HQV",children:"our Discord server"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The example from this article you can find in this repo: ",(0,a.jsx)(n.a,{href:"https://github.com/olga24912/AuroraToNearXCCExample",children:"https://github.com/olga24912/AuroraToNearXCCExample"})]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},7507:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(9474);const a={},o=r.createContext(a);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},694:e=>{e.exports=JSON.parse('{"permalink":"/blog/communication-from-aurora-to-near-local-testing","editUrl":"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/blog/communication-from-aurora-to-near-local-testing.md","source":"@site/blog/communication-from-aurora-to-near-local-testing.md","title":"Integration tests for XCC communication","description":"XCC is a powerful tool to merge blockchain ecosystems together. In this post we will talk about how to write integration tests for the XCC contracts communicating between Aurora and Near using Rust","date":"2023-09-08T00:00:00.000Z","tags":[{"inline":false,"label":"Tutorials","permalink":"/blog/tags/tutorials","description":"Longer posts talking about the subject in detail"}],"readingTime":7.196666666666666,"hasTruncateMarker":true,"authors":[{"name":"Olga Kunyavskaya","title":"Bridge Engineer","imageURL":"https://www.datocms-assets.com/95026/1683043237-t025c6kc9px-u03dl8hkg1w-fe48e17d7ba2-512.png","key":"olga","page":null}],"frontMatter":{"title":"Integration tests for XCC communication","description":"XCC is a powerful tool to merge blockchain ecosystems together. In this post we will talk about how to write integration tests for the XCC contracts communicating between Aurora and Near using Rust","date":"2023-09-08","authors":["olga"],"tags":["tutorials"],"image":"https://www.datocms-assets.com/95026/1694085970-article-cover.png"},"unlisted":false,"prevItem":{"title":"Practical ERC20 Burning","permalink":"/blog/practical-erc20-burning"},"nextItem":{"title":"Turning Smart Contracts into Indexers","permalink":"/blog/turning-smart-contracts-into-indexers"}}')}}]);