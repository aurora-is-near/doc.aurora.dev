"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[7186],{8613:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"crosschain/xcc/aurora-to-near/usage-examples","title":"Usage Examples","description":"Tic-Tac-Toe XCC Example","source":"@site/docs/crosschain/xcc/aurora-to-near/usage-examples.md","sourceDirName":"crosschain/xcc/aurora-to-near","slug":"/crosschain/xcc/aurora-to-near/usage-examples","permalink":"/crosschain/xcc/aurora-to-near/usage-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/docs/crosschain/xcc/aurora-to-near/usage-examples.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Usage examples","title":"Usage Examples"},"sidebar":"developers","previous":{"title":"Introduction","permalink":"/crosschain/xcc/aurora-to-near/introduction"},"next":{"title":"Introduction","permalink":"/crosschain/xcc/near-to-aurora/introduction"}}');var r=t(3274),o=t(7507);const s={sidebar_label:"Usage examples",title:"Usage Examples"},i=void 0,c={},l=[{value:"Tic-Tac-Toe XCC Example",id:"tic-tac-toe-xcc-example",level:2},{value:"<code>social-db</code> from Aurora",id:"social-db-from-aurora",level:2},{value:"Fungible token refund",id:"fungible-token-refund",level:2}];function h(e){const a={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h2,{id:"tic-tac-toe-xcc-example",children:"Tic-Tac-Toe XCC Example"}),"\n",(0,r.jsx)(a.p,{children:"In this example, the dApp is a tic-tac-toe game where the board state and game management are handled in Solidity, while the Computer opponent logic is in Rust.\nThe purpose of this example is to illustrate how you can use the strengths of both Aurora and Near to build one unified dApp, in the same way that a single Web 2.0 application\ncan consist of both JavaScript and WebAssembly components.\nIn this particular case the whole thing could have been written for either platform.\nBut you can imagine how a real use-case might involve solutions to multiple problems, some of which are easier to solve in Solidity (for example maybe there is a convenient OpenZepillin library)\nand others easier in Rust or in the Near ecosystem in general (for example maybe you want to take advantage of the protocol-level account abstraction)."}),"\n",(0,r.jsxs)(a.p,{children:["This project has been deployed to testnet!\nYou can interact with it ",(0,r.jsx)(a.a,{href:"https://bos.gg/#/nearcon.birchmd.near/widget/Aurora-Tic-Tac-Toe",children:"live on the Blockchain Operating System (BOS)"}),".\nIf you don't want to interact with it yourself you can ",(0,r.jsx)(a.a,{href:"https://youtu.be/_tSuGRN9Lok",children:"watch the demo on YouTube"}),"."]}),"\n",(0,r.jsxs)(a.p,{children:["You can read an article about this on our DevPortal ",(0,r.jsx)(a.a,{href:"/blog/building-a-game-using-near-aurora-and-bos",children:"here"}),"."]}),"\n",(0,r.jsxs)(a.p,{children:["And also find the repo by this ",(0,r.jsx)(a.a,{href:"https://github.com/aurora-is-near/aurora-contracts-sdk/tree/main/examples/tic-tac-toe",children:"link"}),"."]}),"\n",(0,r.jsxs)(a.h2,{id:"social-db-from-aurora",children:[(0,r.jsx)(a.code,{children:"social-db"})," from Aurora"]}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.code,{children:"social-db"})," is the storage layer backing ",(0,r.jsx)(a.a,{href:"https://near.social/",children:"near.social"}),", a decentralized social media platform on the Near blockchain.\nIt is realised as a smart contract on the Near blockchain."]}),"\n",(0,r.jsxs)(a.p,{children:["In this example we show how to interact with ",(0,r.jsx)(a.code,{children:"social-db"})," from the Aurora EVM using the XCC feature.\nIn particular, we expose the ",(0,r.jsx)(a.a,{href:"https://github.com/NearSocial/social-db/tree/39016e654739b0a3e8cb7ffaea4b03157c4aea6e#storing-data",children:"set method"}),"\nof the SocialDB contract to allow storing data in the DB from Aurora:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-solidity",children:'    // Exposes the [set interface](https://github.com/NearSocial/social-db/tree/39016e654739b0a3e8cb7ffaea4b03157c4aea6e#storing-data)\n    // of the SocialDB contract. This function is access controlled because it is important that\n    // only authorized users can instruct keys to be set in the DB.\n    // An amount of wNEAR is also required for this call to cover the storage cost of the data\n    // being persisted on Near.\n    function set(uint128 attachedNear, bytes memory data) public onlyRole(SETTER_ROLE) {\n        wNEAR.transferFrom(msg.sender, address(this), attachedNear);\n\n        PromiseCreateArgs memory callSet =\n            near.call(socialdbAccountId, "set", data, attachedNear, SET_NEAR_GAS);\n        PromiseCreateArgs memory callback =\n            near.auroraCall(address(this), abi.encodePacked(this.setCallback.selector), 0, SET_CALLBACK_NEAR_GAS);\n\n        callSet.then(callback).transact();\n    }\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Take a look at ",(0,r.jsx)(a.a,{href:"https://github.com/aurora-is-near/aurora-contracts-sdk/tree/main/examples/social-db-from-aurora",children:"the full repo here"}),"."]}),"\n",(0,r.jsx)(a.h2,{id:"fungible-token-refund",children:"Fungible token refund"}),"\n",(0,r.jsx)(a.p,{children:"The purpose of this example is to demonstrate a proper way to do token bridging between Near and Aurora and to properly refund tokens that might have been stuck in the XCC contract otherwise."}),"\n",(0,r.jsxs)(a.p,{children:["More specifically, we have a Solidity contract ",(0,r.jsx)(a.code,{children:"S"})," on Aurora which sends a fungible token (FT) on Near via calling ",(0,r.jsx)(a.code,{children:"ft_transfer_call"})," on its contract ",(0,r.jsx)(a.code,{children:"T"}),".\nThere is another receiving Near contract ",(0,r.jsx)(a.code,{children:"R"}),", which denies the sent FT in its ",(0,r.jsx)(a.code,{children:"ft_on_transfer"})," function, resulting in a refund from ",(0,r.jsx)(a.code,{children:"T"})," to the XCC contract address.\nThe XCC contract now needs to bridge back the FT to the signing EVM wallet by calling ",(0,r.jsx)(a.code,{children:"ft_transfer_call"})," on the token again, this time sending the tokens to Aurora."]}),"\n",(0,r.jsxs)(a.p,{children:["If you want to read a detailed article on our DevPortal about this example, here is the ",(0,r.jsx)(a.a,{href:"/blog/contract-callbacks-in-xcc",children:"link"}),"."]}),"\n",(0,r.jsx)(a.p,{children:"An overview is given in the following diagram:"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.img,{alt:"Overview diagram",src:t(883).A+"",width:"5708",height:"2118"})}),"\n",(0,r.jsxs)(a.p,{children:["A key aspect of this example is the fact that a callback to Aurora makes a further cross-contract call (XCC) which also spends NEAR (since ",(0,r.jsx)(a.code,{children:"ft_transfer_call"})," requires 1 yoctoNEAR attached).\nThis is a little tricky to get right because the sender of the callback transaction to Aurora is derived from the XCC representative account on NEAR by hashing the account ID.\nIt is not equal to the address of the contract which caused the callback to be sent.\nTherefore, additional setup is required to make this work; there must be an extra XCC call into Aurora where the derived account gives allowance to the Solidity contract to spend its WNEAR."]})]})}function d(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},883:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/ft-refund-overview-50e65f9d3d3c8166e6b9bb576a731d55.svg"},7507:(e,a,t)=>{t.d(a,{R:()=>s,x:()=>i});var n=t(9474);const r={},o=n.createContext(r);function s(e){const a=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);