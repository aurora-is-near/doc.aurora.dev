"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[8887],{90573:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"crosschain/xcc/near-to-aurora/introduction","title":"Near to Aurora XCC","description":"This article describes the concepts involved in using Wasm-based smart contracts deployed on Near to interact with EVM-based smart contracts deployed on Aurora.","source":"@site/docs/crosschain/xcc/near-to-aurora/introduction.md","sourceDirName":"crosschain/xcc/near-to-aurora","slug":"/crosschain/xcc/near-to-aurora/introduction","permalink":"/crosschain/xcc/near-to-aurora/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/docs/crosschain/xcc/near-to-aurora/introduction.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Introduction","title":"Near to Aurora XCC"},"sidebar":"developers","previous":{"title":"Usage examples","permalink":"/crosschain/xcc/aurora-to-near/usage-examples"},"next":{"title":"Usage examples","permalink":"/crosschain/xcc/near-to-aurora/usage-examples"}}');var r=a(13274),o=a(77507);const c={sidebar_label:"Introduction",title:"Near to Aurora XCC"},s=void 0,i={},d=[{value:"Implicit EVM Address",id:"implicit-evm-address",level:2},{value:"Aurora interface for &#39;deploy_code&#39;",id:"aurora-interface-for-deploy_code",level:2},{value:"Aurora interface for &#39;call&#39;",id:"aurora-interface-for-call",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["This article describes the concepts involved in using Wasm-based smart contracts deployed on ",(0,r.jsx)(t.a,{href:"https://near.org/",children:"Near"})," to interact with EVM-based smart contracts deployed on Aurora."]}),"\n",(0,r.jsx)(t.p,{children:"We need to learn about the 3 main concepts to understand how it works:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Implicit EVM Address"}),"\n",(0,r.jsxs)(t.li,{children:["Aurora interface for ",(0,r.jsx)(t.code,{children:"deploy_code"})]}),"\n",(0,r.jsxs)(t.li,{children:["Aurora interface for ",(0,r.jsx)(t.code,{children:"call"})]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"implicit-evm-address",children:"Implicit EVM Address"}),"\n",(0,r.jsxs)(t.p,{children:['When a call is made to a contract on Near there is always a predecessor account ID.\nThis is the account ID that initiated the transaction in the case of a direct call, or the previous contract in the case of a cross-contract call.\nThe Aurora EVM uses the predecessor account ID to create an "implicit address" that is used as the origin for any EVM transactions that are caused by a Near call.\nThe ',(0,r.jsx)(t.code,{children:"submit"})," function is an exception to this since it takes signed EVM transactions directly, therefore the origin address can be derived from the Secp256k1 signature on that EVM transaction.\nHowever, Near contracts will generally interact with Aurora via the ",(0,r.jsx)(t.code,{children:"deploy_code"})," and ",(0,r.jsx)(t.code,{children:"call"})," methods and so the implicit address is an important concept to understand.\nThe reason ",(0,r.jsx)(t.code,{children:"submit"})," cannot be used by Near contracts is because there would be no way to keep a secret key safe on-chain (all on-chain data is public knowledge)."]}),"\n",(0,r.jsxs)(t.p,{children:["The implicit EVM address of a Near account ID is derived by taking the last 20 bytes of the keccak256 hash of the account ID.\nFor example ",(0,r.jsx)(t.code,{children:"alice.near"})," has an implicit address ",(0,r.jsx)(t.code,{children:"0x10315b5BE6B5369E2188C8d7b18ec932c936a21e"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["The EVM does not treat these implicit addresses special compared to any other address.\nThey can hold an ETH balance, they have a nonce, will be the ",(0,r.jsx)(t.code,{children:"msg.sender"}),' when making contract calls, etc.\nYou can think of the "implicit address" as being the identity of that Near account inside the EVM.']}),"\n",(0,r.jsxs)(t.p,{children:["The implicit address for any Near account ID can be computed using the Aurora Rust SDK with the function ",(0,r.jsx)(t.code,{children:"near_account_to_evm_address"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"aurora-interface-for-deploy_code",children:"Aurora interface for 'deploy_code'"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.a,{href:"https://github.com/aurora-is-near/aurora-engine",children:"Aurora Engine"})," is the smart contract that contains the EVM.\nIt has two main methods for interacting with the EVM from Near contracts.\nThe ",(0,r.jsx)(t.code,{children:"deploy_code"})," function is used to deploy new EVM contracts.\nIt takes as input the raw EVM bytecode that is used to deploy the contract.\nNote that if this bytecode is obtained from compiling a Solidity contract with a constructor that takes arguments then you will need to be sure those arguments are properly encoded as part of\nthe bytecode sent to ",(0,r.jsx)(t.code,{children:"deploy_code"}),". The encoded arguments have to be appended to the contracts bytecode since the constructor is invoked during deployment.\nFor example you can use a library like ",(0,r.jsx)(t.a,{href:"https://crates.io/crates/ethabi",children:"ethabi"})," to encode the deploy arguments correctly."]}),"\n",(0,r.jsx)(t.h2,{id:"aurora-interface-for-call",children:"Aurora interface for 'call'"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"call"})," function of the Aurora Engine is used for Near contracts to call EVM contracts.\nThe input and output are both ",(0,r.jsx)(t.a,{href:"https://borsh.io/",children:"Borsh-encoded"}),".\nThe input is a versioned enum due to allowing it to evolve in a backwards compatible way.\nThe current version looks like"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[derive(BorshSerialize, BorshDeserialize, Debug, PartialEq, Eq, Clone)]\npub struct FunctionCallArgsV2 {\n    pub contract: Address,\n    /// Wei compatible Borsh-encoded value field to attach an ETH balance to the transaction\n    pub value: WeiU256,\n    pub input: Vec<u8>,\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["where ",(0,r.jsx)(t.code,{children:"contract"})," is the address of the EVM contract you are calling, ",(0,r.jsx)(t.code,{children:"value"})," is the amount of Wei (1 ETH = 10^18 Wei) the implicit address will spend on the call\n(encoded as a 256-bit big endian unsigned integer), and ",(0,r.jsx)(t.code,{children:"input"})," is the data passed to the contract. The attached ",(0,r.jsx)(t.code,{children:"value"})," will be deducted from the implicit EVM address corresponding\nto the Near account ID that invokes ",(0,r.jsx)(t.code,{children:"call"}),".\nThe input data will generally be encoded using the Solidity ABI, again a library like ",(0,r.jsx)(t.a,{href:"https://crates.io/crates/ethabi",children:"ethabi"})," can be helpful here.\nNote that the EVM will not charge any ETH for gas because the transaction is still running on Near (the EVM is just another Near smart contract) so the computational cost is covered\nby the NEAR spent to execute the call in the first place."]}),"\n",(0,r.jsxs)(t.p,{children:["The Aurora Rust SDK contains the ",(0,r.jsx)(t.code,{children:"CallArgs"})," type definition which can be used to make well-formed invocations of ",(0,r.jsx)(t.code,{children:"call"}),".\nSee also the ",(0,r.jsx)(t.code,{children:"examples"})," directory of this repository for examples of making calls to Aurora from Near."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},77507:(e,t,a)=>{a.d(t,{R:()=>c,x:()=>s});var n=a(79474);const r={},o=n.createContext(r);function c(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);